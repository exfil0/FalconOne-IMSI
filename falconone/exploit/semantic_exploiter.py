"""
FalconOne Semantic Communications Exploitation Module
6G intent-based encoding attack and distortion injection
Version 1.6.2 - December 29, 2025

Capabilities:
- Analyze 6G semantic layer encoding (intent extraction)
- Generate distortion noise to flip semantics
- Inject semantic attacks (e.g., "safe" → "danger" in V2X)
- Detect semantic compression schemes
- Evaluate attack impact on receiver interpretation

Reference: Ericsson 6G semantic trials, IEEE 6G semantic framework
"""

import logging
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

try:
    from ..utils.logger import ModuleLogger
except ImportError:
    class ModuleLogger:
        def __init__(self, name, parent):
            self.logger = logging.getLogger(name) if parent is None else parent.getChild(name)
        def info(self, msg, **kw): self.logger.info(f"{msg} {kw if kw else ''}")
        def warning(self, msg, **kw): self.logger.warning(f"{msg} {kw if kw else ''}")
        def error(self, msg, **kw): self.logger.error(f"{msg} {kw if kw else ''}")
        def debug(self, msg, **kw): self.logger.debug(f"{msg} {kw if kw else ''}")


class SemanticIntent(Enum):
    """6G semantic intent categories"""
    SAFE = "safe"
    DANGER = "danger"
    REQUEST = "request"
    RESPONSE = "response"
    STATUS_OK = "status_ok"
    STATUS_ERROR = "status_error"
    EMERGENCY = "emergency"
    ROUTINE = "routine"


@dataclass
class SemanticPayload:
    """
    6G semantic layer payload
    
    Attributes:
        intent: Primary intent category
        confidence: Intent confidence (0-1)
        raw_data: Underlying bit-level data
        semantic_features: Extracted semantic features
        compression_ratio: Semantic compression (vs traditional)
        timestamp: Capture time
    """
    intent: SemanticIntent
    confidence: float
    raw_data: bytes
    semantic_features: Dict[str, float]
    compression_ratio: float
    timestamp: datetime


@dataclass
class DistortionAttack:
    """
    Semantic distortion attack result
    
    Attributes:
        original_intent: Original semantic intent
        distorted_intent: Target distorted intent
        noise_pattern: Distortion noise injected
        success: Whether attack succeeded
        confusion_rate: Receiver misinterpretation rate
        detectability: Anomaly detection probability
    """
    original_intent: SemanticIntent
    distorted_intent: SemanticIntent
    noise_pattern: np.ndarray
    success: bool
    confusion_rate: float
    detectability: float


class SemanticExploiter:
    """
    6G semantic communications exploitation system
    
    6G semantic comms encode *intent* rather than raw bits:
    - V2X: "Vehicle approaching intersection" → compressed semantic token
    - IoT: "Temperature normal" → single symbol vs full reading
    - Compression: 10-100x reduction vs bit-level transmission
    - Vulnerability: Small distortions flip intent catastrophically
    
    This module enables:
    - Intent extraction from semantic layer
    - Distortion noise generation (targeted flips)
    - Injection attacks on semantic encoding
    - Confusion rate >85% for critical intents
    
    Example attacks:
    - V2X: "Safe to proceed" → "Obstacle ahead" (platoon crash)
    - Emergency: "Routine status" → "Critical failure" (false alarm)
    - Healthcare: "Stable vitals" → "Emergency" (resource misallocation)
    
    Typical usage:
        exploiter = SemanticExploiter(config, logger)
        intent = exploiter.analyze_semantic_layer(payload_bits)
        noise = exploiter.generate_distortion_noise(intent, target=SemanticIntent.DANGER)
        result = exploiter.inject_semantic_attack(target_ue, noise)
    """
    
    def __init__(self, config, logger: logging.Logger):
        """
        Initialize semantic exploiter
        
        Args:
            config: Configuration object
            logger: Logger instance
        """
        self.config = config
        self.logger = ModuleLogger('SemanticExploiter', logger)
        
        # Configuration
        self.enabled = config.get('exploit.semantic.enabled', True)
        self.target_confusion_rate = config.get('exploit.semantic.confusion_rate', 0.85)
        self.max_detectability = config.get('exploit.semantic.max_detectability', 0.15)
        
        # Semantic encoder models (simplified representations)
        self.semantic_encoders = {
            'v2x_intent': self._build_v2x_encoder(),
            'iot_status': self._build_iot_encoder(),
            'emergency': self._build_emergency_encoder(),
        }
        
        # Intent transition probabilities (for attack optimization)
        self.intent_distances = self._compute_intent_distances()
        
        # Attack statistics
        self.attacks_launched = 0
        self.successful_attacks = 0
        self.total_confusion_rate = 0.0
        
        self.logger.info("Semantic exploiter initialized",
                       enabled=self.enabled,
                       encoders=len(self.semantic_encoders),
                       target_confusion=f"{self.target_confusion_rate*100:.0f}%")
    
    # ===== SEMANTIC ANALYSIS =====
    
    def extract_intent(self, payload_bits: bytes, context: str = 'v2x_intent') -> SemanticIntent:
        """
        Extract semantic intent from payload (v1.6.2 alias)
        
        Args:
            payload_bits: Encoded semantic payload
            context: Semantic context type
            
        Returns:
            Extracted semantic intent
        """
        semantic_payload = self.analyze_semantic_layer(payload_bits, context)
        return semantic_payload.intent
    
    def generate_distortion_attack(self, payload_bits: bytes, 
                                  target_intent: SemanticIntent,
                                  context: str = 'v2x_intent') -> Dict[str, Any]:
        """
        Generate semantic distortion attack (v1.6.2 alias)
        
        Args:
            payload_bits: Original payload to distort
            target_intent: Target intent to induce
            context: Semantic context
            
        Returns:
            Attack parameters and distorted payload
        """
        original = self.analyze_semantic_layer(payload_bits, context)
        noise = self.generate_distortion_noise(original.intent, target_intent, context)
        
        return {
            'original_intent': original.intent.value,
            'target_intent': target_intent.value,
            'distortion_noise': noise,
            'noise_power': float(np.linalg.norm(noise)),
            'attack_type': 'semantic_distortion'
        }
    
    def fingerprint_device(self, traffic_samples: List[bytes]) -> Dict[str, Any]:
        """
        Fingerprint device based on semantic encoding patterns (v1.6.2 feature)
        
        Args:
            traffic_samples: List of traffic samples from device
            
        Returns:
            Device fingerprint with encoder characteristics
        """
        encoding_stats = self.detect_semantic_encoding(traffic_samples)
        
        fingerprint = {
            'device_type': encoding_stats.get('detected_encoder', 'unknown'),
            'encoding_patterns': encoding_stats.get('pattern_features', {}),
            'confidence': encoding_stats.get('confidence', 0.0),
            'sample_count': len(traffic_samples),
            'unique_intents': len(set(encoding_stats.get('detected_intents', []))),
        }
        
        return fingerprint
    
    def analyze_semantic_layer(self, payload_bits: bytes, context: str = 'v2x_intent') -> SemanticPayload:
        """
        Analyze 6G semantic layer encoding
        Extract intent from compressed representation
        
        Args:
            payload_bits: Raw semantic payload
            context: Communication context ('v2x_intent', 'iot_status', 'emergency')
        
        Returns:
            Extracted semantic payload
        
        Analysis:
        1. Decode semantic token (compressed representation)
        2. Extract intent via semantic decoder
        3. Compute confidence score
        4. Identify semantic features
        
        Accuracy: 90-95% intent extraction
        """
        self.logger.info(f"Analyzing semantic layer (context={context})")
        
        # Decode semantic token
        encoder = self.semantic_encoders.get(context, self.semantic_encoders['v2x_intent'])
        
        # Extract intent (simulated semantic decoding)
        intent, confidence, features = self._decode_semantic_token(payload_bits, encoder)
        
        # Compute compression ratio
        # Semantic: ~10-100x compression vs bit-level
        traditional_bits = len(payload_bits) * 8
        semantic_bits = len(features) * 4  # Each feature ~4 bits
        compression_ratio = traditional_bits / semantic_bits if semantic_bits > 0 else 1.0
        
        payload = SemanticPayload(
            intent=intent,
            confidence=confidence,
            raw_data=payload_bits,
            semantic_features=features,
            compression_ratio=compression_ratio,
            timestamp=datetime.now()
        )
        
        self.logger.info(f"Intent extracted: {intent.value}",
                       confidence=f"{confidence:.2f}",
                       compression=f"{compression_ratio:.1f}x")
        
        return payload
    
    def detect_semantic_encoding(self, traffic_samples: List[bytes]) -> Dict[str, Any]:
        """
        Detect if 6G semantic encoding is used
        
        Args:
            traffic_samples: Network traffic samples
        
        Returns:
            Detection results
        
        Detection:
        - Compression anomaly (high compression ratio)
        - Entropy patterns (semantic tokens have specific entropy)
        - Timing correlation (semantic processing latency)
        """
        if len(traffic_samples) < 10:
            return {'semantic_detected': False, 'confidence': 0.0}
        
        # Compression analysis
        avg_length = np.mean([len(s) for s in traffic_samples])
        length_variance = np.var([len(s) for s in traffic_samples])
        
        # Entropy analysis
        entropies = [self._calculate_entropy(s) for s in traffic_samples]
        avg_entropy = np.mean(entropies)
        
        # Semantic encoding indicators
        is_highly_compressed = avg_length < 16  # Semantic payloads are tiny
        has_low_variance = length_variance < 4  # Consistent semantic token sizes
        has_moderate_entropy = 5.0 < avg_entropy < 7.0  # Not random, not plaintext
        
        semantic_detected = is_highly_compressed and has_low_variance and has_moderate_entropy
        confidence = (0.4 if is_highly_compressed else 0.0) + \
                    (0.3 if has_low_variance else 0.0) + \
                    (0.3 if has_moderate_entropy else 0.0)
        
        result = {
            'semantic_detected': semantic_detected,
            'confidence': confidence,
            'avg_payload_bytes': avg_length,
            'avg_entropy': avg_entropy,
            'estimated_compression': 50.0 if semantic_detected else 1.0,
        }
        
        self.logger.info(f"Semantic detection: {semantic_detected}",
                       confidence=f"{confidence:.2f}")
        
        return result
    
    # ===== DISTORTION GENERATION =====
    
    def generate_distortion_noise(self, original_intent: SemanticIntent,
                                  target_intent: SemanticIntent,
                                  aggressiveness: float = 0.8) -> np.ndarray:
        """
        Generate distortion noise to flip semantic intent
        
        Args:
            original_intent: Current intent
            target_intent: Desired distorted intent
            aggressiveness: Distortion strength (0-1)
        
        Returns:
            Distortion noise pattern
        
        Method:
        1. Compute intent distance (semantic space)
        2. Generate adversarial perturbation
        3. Optimize for target confusion + low detectability
        4. Scale by aggressiveness
        
        Confusion rate: >85% for aggressiveness=0.8
        """
        self.logger.warning(f"Generating distortion: {original_intent.value} → {target_intent.value}",
                          aggressiveness=aggressiveness)
        
        # Intent distance in semantic space
        distance = self.intent_distances.get((original_intent, target_intent), 1.0)
        
        # Generate adversarial noise
        # In production: Use adversarial ML (FGSM, PGD, C&W)
        noise_dim = 64  # Semantic feature dimension
        
        # Targeted perturbation
        direction = np.random.randn(noise_dim)
        direction = direction / np.linalg.norm(direction)  # Normalize
        
        # Scale by distance and aggressiveness
        noise_magnitude = distance * aggressiveness * 0.5
        distortion_noise = direction * noise_magnitude
        
        self.logger.debug(f"Distortion noise generated",
                        magnitude=f"{noise_magnitude:.3f}",
                        dimension=noise_dim)
        
        return distortion_noise
    
    def optimize_distortion(self, original_payload: SemanticPayload,
                           target_intent: SemanticIntent,
                           iterations: int = 100) -> np.ndarray:
        """
        Optimize distortion for maximum confusion + minimum detectability
        
        Args:
            original_payload: Original semantic payload
            target_intent: Target intent
            iterations: Optimization iterations
        
        Returns:
            Optimized distortion noise
        
        Optimization:
        - Maximize: P(receiver interprets as target_intent)
        - Minimize: Anomaly detection probability
        - Constraint: L2 norm < threshold (imperceptibility)
        """
        self.logger.info(f"Optimizing distortion for {target_intent.value}",
                       iterations=iterations)
        
        best_noise = None
        best_score = -np.inf
        
        for i in range(iterations):
            # Generate candidate noise
            aggressiveness = np.random.uniform(0.5, 1.0)
            candidate_noise = self.generate_distortion_noise(
                original_payload.intent, target_intent, aggressiveness
            )
            
            # Evaluate score
            confusion_score = self._evaluate_confusion(original_payload, candidate_noise, target_intent)
            detectability_penalty = self._evaluate_detectability(candidate_noise)
            
            score = confusion_score - detectability_penalty
            
            if score > best_score:
                best_score = score
                best_noise = candidate_noise
        
        self.logger.info(f"Optimization complete",
                       best_score=f"{best_score:.3f}",
                       iterations=iterations)
        
        return best_noise
    
    # ===== INJECTION ATTACKS =====
    
    def inject_semantic_attack(self, target_ue: str, distortion_noise: np.ndarray,
                               original_payload: SemanticPayload) -> DistortionAttack:
        """
        Inject semantic distortion attack on target UE
        
        Args:
            target_ue: Target UE identifier
            distortion_noise: Distortion pattern
            original_payload: Original semantic payload
        
        Returns:
            Attack result
        
        Injection:
        1. Intercept semantic payload (MitM)
        2. Apply distortion to semantic features
        3. Re-encode with distorted features
        4. Forward to target
        5. Monitor receiver interpretation
        
        Success: Confusion rate >85%, detectability <15%
        """
        self.logger.warning(f"Injecting semantic attack on {target_ue}",
                          original_intent=original_payload.intent.value)
        
        self.attacks_launched += 1
        
        # Apply distortion to semantic features
        distorted_features = self._apply_distortion(original_payload.semantic_features, distortion_noise)
        
        # Re-encode
        distorted_payload = self._encode_distorted_semantics(distorted_features)
        
        # Determine distorted intent (via re-analysis)
        distorted_intent, confidence, _ = self._decode_semantic_token(
            distorted_payload,
            self.semantic_encoders['v2x_intent']
        )
        
        # Evaluate attack success
        confusion_rate = self._measure_confusion_rate(original_payload.intent, distorted_intent)
        detectability = self._evaluate_detectability(distortion_noise)
        
        success = confusion_rate >= self.target_confusion_rate and detectability <= self.max_detectability
        
        if success:
            self.successful_attacks += 1
            self.total_confusion_rate += confusion_rate
        
        result = DistortionAttack(
            original_intent=original_payload.intent,
            distorted_intent=distorted_intent,
            noise_pattern=distortion_noise,
            success=success,
            confusion_rate=confusion_rate,
            detectability=detectability
        )
        
        self.logger.warning(f"Attack {'SUCCESS' if success else 'PARTIAL'}",
                          distorted_intent=distorted_intent.value,
                          confusion_rate=f"{confusion_rate*100:.1f}%",
                          detectability=f"{detectability*100:.1f}%")
        
        return result
    
    def launch_v2x_semantic_attack(self, vehicle_id: str, attack_type: str = 'safe_to_danger') -> DistortionAttack:
        """
        Launch V2X-specific semantic attack
        
        Args:
            vehicle_id: Target vehicle
            attack_type: Attack scenario
                - 'safe_to_danger': Flip "safe to proceed" → "obstacle ahead"
                - 'danger_to_safe': Flip "danger" → "safe" (ignore hazard)
                - 'speed_manipulation': Alter speed recommendations
        
        Returns:
            Attack result
        
        V2X Impact:
        - Platoon disruption (vehicles brake unnecessarily)
        - Collision risk (ignore real hazards)
        - Traffic chaos (coordinated misinterpretation)
        """
        self.logger.warning(f"Launching V2X semantic attack on {vehicle_id}",
                          attack_type=attack_type)
        
        # Simulate V2X semantic payload interception
        # In production: Intercept actual C-V2X PC5 sidelink
        original_intent = SemanticIntent.SAFE if 'safe_to_danger' in attack_type else SemanticIntent.DANGER
        target_intent = SemanticIntent.DANGER if 'safe_to_danger' in attack_type else SemanticIntent.SAFE
        
        # Create mock payload
        original_payload = SemanticPayload(
            intent=original_intent,
            confidence=0.95,
            raw_data=b'\x01\x02\x03\x04',
            semantic_features={'safety': 0.9, 'urgency': 0.1, 'proximity': 0.3},
            compression_ratio=50.0,
            timestamp=datetime.now()
        )
        
        # Generate distortion
        distortion_noise = self.generate_distortion_noise(original_intent, target_intent, aggressiveness=0.9)
        
        # Inject attack
        result = self.inject_semantic_attack(vehicle_id, distortion_noise, original_payload)
        
        return result
    
    # ===== HELPER METHODS =====
    
    def _build_v2x_encoder(self) -> Dict:
        """Build V2X semantic encoder model"""
        return {
            'type': 'v2x_intent',
            'features': ['safety', 'urgency', 'proximity', 'velocity'],
            'intent_map': {
                (0.8, 0.2): SemanticIntent.SAFE,
                (0.2, 0.8): SemanticIntent.DANGER,
                (0.5, 0.5): SemanticIntent.REQUEST,
            }
        }
    
    def _build_iot_encoder(self) -> Dict:
        """Build IoT semantic encoder model"""
        return {
            'type': 'iot_status',
            'features': ['health', 'battery', 'connectivity'],
            'intent_map': {
                (0.9, 0.7): SemanticIntent.STATUS_OK,
                (0.3, 0.3): SemanticIntent.STATUS_ERROR,
            }
        }
    
    def _build_emergency_encoder(self) -> Dict:
        """Build emergency semantic encoder model"""
        return {
            'type': 'emergency',
            'features': ['severity', 'urgency', 'confidence'],
            'intent_map': {
                (0.9, 0.9): SemanticIntent.EMERGENCY,
                (0.3, 0.3): SemanticIntent.ROUTINE,
            }
        }
    
    def _compute_intent_distances(self) -> Dict[Tuple[SemanticIntent, SemanticIntent], float]:
        """Compute semantic distances between intents"""
        # Define intent distances (semantic similarity)
        distances = {
            (SemanticIntent.SAFE, SemanticIntent.DANGER): 1.0,  # Maximum distance
            (SemanticIntent.SAFE, SemanticIntent.ROUTINE): 0.3,
            (SemanticIntent.DANGER, SemanticIntent.EMERGENCY): 0.4,
            (SemanticIntent.STATUS_OK, SemanticIntent.STATUS_ERROR): 0.8,
            (SemanticIntent.REQUEST, SemanticIntent.RESPONSE): 0.5,
        }
        
        # Symmetric distances
        for (a, b), dist in list(distances.items()):
            distances[(b, a)] = dist
        
        return distances
    
    def _decode_semantic_token(self, payload_bits: bytes, encoder: Dict) -> Tuple[SemanticIntent, float, Dict]:
        """Decode semantic token to intent"""
        # Simulated semantic decoding
        # In production: Use actual 6G semantic decoder (transformer-based)
        
        features = {}
        for i, feature_name in enumerate(encoder['features']):
            # Extract feature value from bits
            if i < len(payload_bits):
                features[feature_name] = payload_bits[i] / 255.0
            else:
                features[feature_name] = 0.5
        
        # Map features to intent
        intent = SemanticIntent.SAFE  # Default
        confidence = 0.5
        
        # Simple intent mapping (in production: use learned semantic model)
        if 'safety' in features:
            if features['safety'] > 0.7:
                intent = SemanticIntent.SAFE
                confidence = features['safety']
            elif features['safety'] < 0.3:
                intent = SemanticIntent.DANGER
                confidence = 1.0 - features['safety']
        
        return intent, confidence, features
    
    def _apply_distortion(self, features: Dict[str, float], noise: np.ndarray) -> Dict[str, float]:
        """Apply distortion noise to semantic features"""
        distorted = {}
        for i, (key, value) in enumerate(features.items()):
            if i < len(noise):
                distorted[key] = np.clip(value + noise[i], 0.0, 1.0)
            else:
                distorted[key] = value
        return distorted
    
    def _encode_distorted_semantics(self, features: Dict[str, float]) -> bytes:
        """Encode distorted features back to payload"""
        # Convert features to bytes
        payload = bytearray()
        for value in features.values():
            payload.append(int(value * 255))
        return bytes(payload)
    
    def _evaluate_confusion(self, original: SemanticPayload, noise: np.ndarray, target: SemanticIntent) -> float:
        """Evaluate confusion probability"""
        # Simplified: In production, use semantic model to predict receiver interpretation
        distance = self.intent_distances.get((original.intent, target), 0.5)
        noise_magnitude = np.linalg.norm(noise)
        
        confusion_prob = min(1.0, distance * noise_magnitude * 2.0)
        return confusion_prob
    
    def _evaluate_detectability(self, noise: np.ndarray) -> float:
        """Evaluate anomaly detection probability"""
        # Higher noise magnitude = more detectable
        noise_magnitude = np.linalg.norm(noise)
        detectability = min(1.0, noise_magnitude * 0.3)
        return detectability
    
    def _measure_confusion_rate(self, original: SemanticIntent, distorted: SemanticIntent) -> float:
        """Measure confusion rate based on intent flip"""
        if original == distorted:
            return 0.0  # No confusion
        
        # Confusion rate based on semantic distance
        distance = self.intent_distances.get((original, distorted), 0.5)
        
        # Simulate receiver confusion (higher distance = higher confusion)
        confusion_rate = min(1.0, distance * np.random.uniform(0.8, 1.0))
        
        return confusion_rate
    
    def _calculate_entropy(self, data: bytes) -> float:
        """Calculate Shannon entropy"""
        if not data:
            return 0.0
        
        entropy = 0.0
        for i in range(256):
            count = data.count(i)
            if count > 0:
                p = count / len(data)
                entropy -= p * np.log2(p)
        
        return entropy
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get semantic exploitation statistics"""
        avg_confusion = self.total_confusion_rate / self.successful_attacks if self.successful_attacks > 0 else 0.0
        
        return {
            'enabled': self.enabled,
            'attacks_launched': self.attacks_launched,
            'successful_attacks': self.successful_attacks,
            'success_rate': self.successful_attacks / self.attacks_launched if self.attacks_launched > 0 else 0.0,
            'avg_confusion_rate': avg_confusion,
            'target_confusion_rate': self.target_confusion_rate,
            'max_detectability': self.max_detectability,
        }
