"""
FalconOne Post-Quantum Cryptanalysis Module (v1.5.5)
Targets: Future 6G quantum-resistant cryptography, lattice-based attacks
Author: FalconOne Development Team
"""

import logging
import time
import numpy as np
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime
import hashlib
import secrets

try:
    from ..utils.logger import ModuleLogger
except ImportError:
    class ModuleLogger:
        def __init__(self, name, parent):
            self.logger = logging.getLogger(name) if parent is None else parent.getChild(name)
        def info(self, msg, **kw): self.logger.info(f"{msg} {kw if kw else ''}")
        def warning(self, msg, **kw): self.logger.warning(f"{msg} {kw if kw else ''}")
        def error(self, msg, **kw): self.logger.error(f"{msg} {kw if kw else ''}")
        def debug(self, msg, **kw): self.logger.debug(f"{msg} {kw if kw else ''}")


class LatticeAttack:
    """
    Lattice-based cryptanalysis for post-quantum schemes
    Targets: CRYSTALS-Kyber, CRYSTALS-Dilithium (NIST PQC finalists)
    """
    
    def __init__(self, dimension: int = 256):
        self.dimension = dimension  # Lattice dimension (n)
        self.modulus = 3329  # q (prime modulus for Kyber)
        
    def approximate_svp(self, basis: np.ndarray, target_norm: float) -> Optional[np.ndarray]:
        """
        Approximate Shortest Vector Problem (SVP) solver using LLL algorithm
        
        Args:
            basis: Lattice basis matrix (n x n)
            target_norm: Target vector norm threshold
            
        Returns:
            Short vector if found, None otherwise
        """
        try:
            # Simplified LLL algorithm (production: use fpylll library)
            reduced_basis = self._lll_reduce(basis)
            
            # Check if shortest vector is below threshold
            shortest_vector = reduced_basis[0]
            norm = np.linalg.norm(shortest_vector)
            
            if norm <= target_norm:
                return shortest_vector
            
            return None
            
        except Exception as e:
            return None
    
    def _lll_reduce(self, basis: np.ndarray, delta: float = 0.75) -> np.ndarray:
        """
        Lenstra-Lenstra-Lovász lattice reduction
        Simplified implementation (use fpylll for production)
        
        Args:
            basis: Lattice basis matrix
            delta: LLL parameter (0.25 < delta < 1)
            
        Returns:
            Reduced basis
        """
        n = basis.shape[0]
        b = basis.copy().astype(float)
        
        # Gram-Schmidt orthogonalization
        b_star = np.zeros_like(b)
        mu = np.zeros((n, n))
        
        for i in range(n):
            b_star[i] = b[i].copy()
            for j in range(i):
                mu[i, j] = np.dot(b[i], b_star[j]) / np.dot(b_star[j], b_star[j])
                b_star[i] -= mu[i, j] * b_star[j]
        
        # LLL reduction
        k = 1
        while k < n:
            # Size reduction
            for j in range(k - 1, -1, -1):
                if abs(mu[k, j]) > 0.5:
                    b[k] -= round(mu[k, j]) * b[j]
                    # Update Gram-Schmidt
                    for i in range(k + 1):
                        b_star[i] = b[i].copy()
                        for l in range(i):
                            mu[i, l] = np.dot(b[i], b_star[l]) / np.dot(b_star[l], b_star[l])
                            b_star[i] -= mu[i, l] * b_star[l]
            
            # Lovász condition
            if np.dot(b_star[k], b_star[k]) >= (delta - mu[k, k-1]**2) * np.dot(b_star[k-1], b_star[k-1]):
                k += 1
            else:
                # Swap vectors
                b[[k, k-1]] = b[[k-1, k]]
                k = max(k - 1, 1)
        
        return b


class PostQuantumCryptoAttack:
    """
    Post-Quantum Cryptanalysis Engine
    Simulates attacks on future 6G quantum-resistant schemes
    """
    
    def __init__(self, config, logger: Optional[logging.Logger] = None):
        self.config = config
        
        # Handle logger initialization
        if logger is None:
            logger = logging.getLogger('FalconOne')
        self.logger = ModuleLogger('Exploit-PostQuantum', logger)
        
        # Configuration
        self.pq_enabled = config.get('exploit.post_quantum.enabled', True) if hasattr(config, 'get') else True
        self.attack_iterations = config.get('exploit.post_quantum.iterations', 1000) if hasattr(config, 'get') else 1000
        
        # Attack results cache
        self.attack_history = []
        
        self.logger.info("Post-Quantum Cryptanalysis Engine initialized (v1.5.5)",
                       pq_enabled=self.pq_enabled)
    
    def attack_kyber_key_exchange(self, public_key: bytes, ciphertext: bytes,
                                  dimension: int = 256) -> Dict[str, Any]:
        """
        Attack CRYSTALS-Kyber key exchange (NIST PQC KEM)
        Exploits potential side-channel leakage or weak implementations
        
        Args:
            public_key: Kyber public key (serialized)
            ciphertext: Kyber ciphertext (encapsulated shared secret)
            dimension: Lattice dimension (256, 512, or 768)
            
        Returns:
            Attack result with recovered secret (if successful)
        """
        self.logger.warning(f"Attacking Kyber-{dimension} key exchange",
                          pub_key_len=len(public_key),
                          ciphertext_len=len(ciphertext))
        
        attack_start = datetime.now()
        
        # Simulate lattice attack on Kyber
        lattice_attacker = LatticeAttack(dimension=dimension)
        
        # Generate synthetic lattice basis from public key (simplified)
        # In production: Parse actual Kyber public key structure
        basis = self._generate_kyber_lattice(public_key, dimension)
        
        # Attempt SVP-based key recovery
        target_norm = dimension ** 0.5  # Heuristic target norm
        short_vector = lattice_attacker.approximate_svp(basis, target_norm)
        
        attack_duration = (datetime.now() - attack_start).total_seconds()
        
        success = short_vector is not None
        
        result = {
            'attack_type': 'kyber_key_exchange',
            'dimension': dimension,
            'success': success,
            'attack_duration_sec': attack_duration,
            'recovered_secret': short_vector.tobytes() if success else None,
            'timestamp': datetime.now().isoformat()
        }
        
        if success:
            self.logger.warning(f"Kyber-{dimension} attack successful!",
                              duration=f"{attack_duration:.2f}s")
        else:
            self.logger.info(f"Kyber-{dimension} attack failed",
                           duration=f"{attack_duration:.2f}s")
        
        self.attack_history.append(result)
        
        return result
    
    def attack_dilithium_signature(self, public_key: bytes, signature: bytes,
                                   message: bytes) -> Dict[str, Any]:
        """
        Attack CRYSTALS-Dilithium digital signature (NIST PQC signature)
        Attempts signature forgery or key recovery
        
        Args:
            public_key: Dilithium public key
            signature: Dilithium signature to analyze
            message: Original signed message
            
        Returns:
            Attack result (forgery or key recovery)
        """
        self.logger.warning("Attacking Dilithium signature scheme",
                          sig_len=len(signature),
                          msg_len=len(message))
        
        attack_start = datetime.now()
        
        # Simulate signature forgery attempt
        # Real attack: Exploit rejection sampling side-channels
        forged_signature = self._attempt_signature_forgery(public_key, message)
        
        attack_duration = (datetime.now() - attack_start).total_seconds()
        
        # Verify forgery (placeholder - would use actual Dilithium verification)
        success = self._verify_forgery(public_key, message, forged_signature)
        
        result = {
            'attack_type': 'dilithium_signature_forgery',
            'success': success,
            'attack_duration_sec': attack_duration,
            'forged_signature': forged_signature if success else None,
            'timestamp': datetime.now().isoformat()
        }
        
        if success:
            self.logger.warning(f"Dilithium forgery successful!",
                              duration=f"{attack_duration:.2f}s")
        else:
            self.logger.info(f"Dilithium attack failed",
                           duration=f"{attack_duration:.2f}s")
        
        self.attack_history.append(result)
        
        return result
    
    def attack_suci_concealment_6g(self, concealed_suci: bytes,
                                   home_network_public_key: bytes) -> Dict[str, Any]:
        """
        Attack 6G SUCI concealment with post-quantum ECIES variant
        Targets future Rel-20+ quantum-resistant SUCI schemes
        
        Args:
            concealed_suci: Encrypted SUCI (SUPI)
            home_network_public_key: Home network's PQ public key
            
        Returns:
            Attack result with deconcealed SUPI (if successful)
        """
        self.logger.warning("Attacking 6G quantum-resistant SUCI concealment",
                          suci_len=len(concealed_suci))
        
        attack_start = datetime.now()
        
        # Simulate attack on PQ-ECIES (hybrid classical + PQ encryption)
        # Attack vectors:
        # 1. Side-channel timing attacks on decapsulation
        # 2. Lattice reduction on weak parameters
        # 3. Fault injection during key generation
        
        deconcealed_supi = self._attack_pq_ecies(concealed_suci, home_network_public_key)
        
        attack_duration = (datetime.now() - attack_start).total_seconds()
        
        success = deconcealed_supi is not None
        
        result = {
            'attack_type': 'suci_deconcealment_6g_pq',
            'success': success,
            'attack_duration_sec': attack_duration,
            'deconcealed_supi': deconcealed_supi,
            'timestamp': datetime.now().isoformat()
        }
        
        if success:
            self.logger.warning(f"6G SUCI deconcealment successful!",
                              supi=deconcealed_supi,
                              duration=f"{attack_duration:.2f}s")
        else:
            self.logger.info(f"SUCI attack failed",
                           duration=f"{attack_duration:.2f}s")
        
        self.attack_history.append(result)
        
        return result
    
    def side_channel_timing_attack(self, target_function: str,
                                   num_samples: int = 10000) -> Dict[str, Any]:
        """
        Side-channel timing attack on PQ cryptographic operations
        Exploits non-constant-time implementations of lattice operations
        
        Args:
            target_function: Target operation ('decapsulation', 'signing', 'verification')
            num_samples: Number of timing samples to collect
            
        Returns:
            Attack result with leaked secret information
        """
        self.logger.warning(f"Side-channel timing attack on {target_function}",
                          samples=num_samples)
        
        attack_start = datetime.now()
        
        # Collect timing samples
        timing_samples = []
        for i in range(num_samples):
            # Simulate timing measurement of target operation
            # In production: Measure actual decapsulation/signing time
            timing = self._measure_operation_time(target_function)
            timing_samples.append(timing)
        
        # Analyze timing distribution for leakage
        timing_array = np.array(timing_samples)
        mean_time = np.mean(timing_array)
        std_time = np.std(timing_array)
        
        # Detect non-constant-time behavior
        leakage_detected = std_time > (mean_time * 0.1)  # >10% variance indicates leakage
        
        attack_duration = (datetime.now() - attack_start).total_seconds()
        
        result = {
            'attack_type': 'side_channel_timing',
            'target_function': target_function,
            'success': leakage_detected,
            'mean_time_us': float(mean_time),
            'std_time_us': float(std_time),
            'num_samples': num_samples,
            'attack_duration_sec': attack_duration,
            'timestamp': datetime.now().isoformat()
        }
        
        if leakage_detected:
            self.logger.warning(f"Timing leakage detected in {target_function}!",
                              mean=f"{mean_time:.2f} us",
                              std=f"{std_time:.2f} us")
        else:
            self.logger.info(f"No timing leakage detected",
                           function=target_function)
        
        self.attack_history.append(result)
        
        return result
    
    def quantum_annealing_simulation(self, problem_matrix: np.ndarray) -> Dict[str, Any]:
        """
        Simulate quantum annealing attack on optimization problems
        (e.g., breaking hash-based signatures via preimage search)
        
        Args:
            problem_matrix: QUBO matrix for quantum annealing
            
        Returns:
            Optimized solution (simulated quantum attack)
        """
        self.logger.warning("Simulating quantum annealing attack",
                          matrix_size=problem_matrix.shape)
        
        attack_start = datetime.now()
        
        # Simulate quantum annealing (classical approximation)
        # Production: Use D-Wave or IBM Quantum APIs
        solution = self._simulated_annealing(problem_matrix)
        
        attack_duration = (datetime.now() - attack_start).total_seconds()
        
        result = {
            'attack_type': 'quantum_annealing_simulation',
            'success': solution is not None,
            'solution': solution.tolist() if solution is not None else None,
            'attack_duration_sec': attack_duration,
            'timestamp': datetime.now().isoformat()
        }
        
        self.logger.info(f"Quantum annealing simulation completed",
                       duration=f"{attack_duration:.2f}s")
        
        self.attack_history.append(result)
        
        return result
    
    def get_attack_history(self) -> List[Dict[str, Any]]:
        """Get list of all post-quantum attacks"""
        return self.attack_history
    
    # ==================== PRIVATE HELPER METHODS ====================
    
    def _generate_kyber_lattice(self, public_key: bytes, dimension: int) -> np.ndarray:
        """Generate synthetic lattice basis from Kyber public key"""
        # Simplified: Use public key hash as seed
        seed = int.from_bytes(hashlib.sha256(public_key).digest()[:8], 'big')
        rng = np.random.default_rng(seed)
        
        # Generate random lattice basis
        basis = rng.integers(-100, 100, size=(dimension, dimension))
        return basis.astype(float)
    
    def _attempt_signature_forgery(self, public_key: bytes, message: bytes) -> bytes:
        """Attempt Dilithium signature forgery"""
        # Placeholder: Generate random signature
        return secrets.token_bytes(2420)  # Dilithium2 signature size
    
    def _verify_forgery(self, public_key: bytes, message: bytes, signature: bytes) -> bool:
        """Verify forged signature (placeholder)"""
        # In production: Use actual Dilithium verification
        return False  # Simulated failure (forgery is hard!)
    
    def _attack_pq_ecies(self, ciphertext: bytes, public_key: bytes) -> Optional[str]:
        """Attack post-quantum ECIES (hybrid encryption)"""
        # Placeholder: Simulate successful attack with low probability
        if secrets.randbelow(100) < 5:  # 5% success rate (simulated)
            return f"imsi-{secrets.randbelow(1000000000000000):015d}"
        return None
    
    def _measure_operation_time(self, operation: str) -> float:
        """Measure timing of cryptographic operation (simulated)"""
        # Simulate timing with noise
        base_time = 100.0  # microseconds
        noise = np.random.normal(0, 10.0)  # 10 us noise
        
        # Add data-dependent timing (leakage)
        if operation == 'decapsulation':
            leakage = np.random.uniform(0, 20.0)  # Non-constant-time operation
            return base_time + noise + leakage
        
        return base_time + noise
    
    def _simulated_annealing(self, qubo_matrix: np.ndarray, 
                            max_iterations: int = 1000) -> Optional[np.ndarray]:
        """Classical simulated annealing (approximates quantum annealing)"""
        n = qubo_matrix.shape[0]
        
        # Random initial solution
        current_solution = np.random.randint(0, 2, size=n)
        current_energy = self._compute_qubo_energy(qubo_matrix, current_solution)
        
        best_solution = current_solution.copy()
        best_energy = current_energy
        
        temperature = 1.0
        cooling_rate = 0.995
        
        for iteration in range(max_iterations):
            # Flip random bit
            new_solution = current_solution.copy()
            flip_idx = np.random.randint(0, n)
            new_solution[flip_idx] = 1 - new_solution[flip_idx]
            
            new_energy = self._compute_qubo_energy(qubo_matrix, new_solution)
            delta_energy = new_energy - current_energy
            
            # Accept or reject
            if delta_energy < 0 or np.random.random() < np.exp(-delta_energy / temperature):
                current_solution = new_solution
                current_energy = new_energy
                
                if current_energy < best_energy:
                    best_solution = current_solution.copy()
                    best_energy = current_energy
            
            temperature *= cooling_rate
        
        return best_solution
    
    def _compute_qubo_energy(self, qubo_matrix: np.ndarray, solution: np.ndarray) -> float:
        """Compute QUBO energy for a given solution"""
        return float(solution.T @ qubo_matrix @ solution)
    
    def generate_attack_report(self) -> Dict[str, Any]:
        """Generate comprehensive post-quantum attack report"""
        if not self.attack_history:
            return {'total_attacks': 0}
        
        successful_attacks = [a for a in self.attack_history if a.get('success')]
        
        return {
            'total_attacks': len(self.attack_history),
            'successful_attacks': len(successful_attacks),
            'success_rate': len(successful_attacks) / len(self.attack_history) if self.attack_history else 0,
            'attack_types': list(set(a['attack_type'] for a in self.attack_history)),
            'avg_duration_sec': np.mean([a['attack_duration_sec'] for a in self.attack_history]),
            'timestamp': datetime.now().isoformat()
        }
    
    # ===== PQ Crypto Hardening & Defensive Simulation (v1.6) =====
    
    def defensive_pq_simulation(self, num_iterations: int = 100) -> Dict[str, Any]:
        """
        Run defensive simulation against PQ attacks
        Tests system resilience and identifies vulnerabilities
        
        Args:
            num_iterations: Number of attack simulations
        
        Returns:
            Defense effectiveness metrics
        
        Tests:
        - Kyber lattice attacks (LLL reduction, BKZ)
        - Dilithium signature forgery
        - Timing side-channels
        - Hybrid scheme fallback behavior
        
        Target: >95% resistance rate
        """
        results = {
            'total_simulations': num_iterations,
            'attacks_blocked': 0,
            'attacks_successful': 0,
            'vulnerabilities': [],
            'timing_leaks': [],
            'hybrid_fallbacks': 0,
        }
        
        self.logger.info(f"Starting defensive PQ simulation ({num_iterations} iterations)")
        
        for i in range(num_iterations):
            # Simulate different attack vectors
            attack_type = np.random.choice(['lattice', 'timing', 'forgery'])
            
            if attack_type == 'lattice':
                # Simulate Kyber lattice attack
                n = 256
                q = 3329
                lattice = self._generate_kyber_lattice(n, q)
                reduced = self._lll_reduce(lattice)
                
                # Check if attack succeeds (simulated)
                attack_success = np.random.random() < 0.05  # 5% base success rate
                
                if attack_success:
                    results['attacks_successful'] += 1
                    results['vulnerabilities'].append({
                        'type': 'lattice_reduction',
                        'iteration': i,
                        'severity': 'high',
                    })
                else:
                    results['attacks_blocked'] += 1
            
            elif attack_type == 'timing':
                # Simulate timing attack
                measurements = []
                for _ in range(100):
                    timing = self._measure_timing('decapsulation')
                    measurements.append(timing)
                
                # Check for timing leakage (high variance = vulnerability)
                variance = np.var(measurements)
                if variance > 50:  # Threshold for significant leakage
                    results['timing_leaks'].append({
                        'iteration': i,
                        'variance': float(variance),
                        'severity': 'medium',
                    })
                    results['attacks_successful'] += 1
                else:
                    results['attacks_blocked'] += 1
            
            elif attack_type == 'forgery':
                # Simulate Dilithium signature forgery
                forgery_success = np.random.random() < 0.02  # 2% base success rate
                
                if forgery_success:
                    results['attacks_successful'] += 1
                    results['vulnerabilities'].append({
                        'type': 'signature_forgery',
                        'iteration': i,
                        'severity': 'critical',
                    })
                else:
                    results['attacks_blocked'] += 1
        
        # Calculate resistance rate
        results['resistance_rate'] = results['attacks_blocked'] / num_iterations
        results['vulnerability_count'] = len(results['vulnerabilities']) + len(results['timing_leaks'])
        results['target_met'] = results['resistance_rate'] >= 0.95
        
        self.logger.info(f"Defensive simulation complete",
                       resistance=f"{results['resistance_rate']*100:.1f}%",
                       vulnerabilities=results['vulnerability_count'],
                       target_met=results['target_met'])
        
        return results
    
    def test_hybrid_schemes(self) -> Dict[str, Any]:
        """
        Test hybrid PQ+classical cryptography schemes
        Provides fallback to ECDH if PQ is compromised
        
        Returns:
            Hybrid scheme test results
        
        Schemes tested:
        - Kyber-768 + ECDH P-256 (KEM)
        - Dilithium-3 + ECDSA P-256 (signatures)
        - Dual PRF combiner for key derivation
        
        Security: Secure if either component is secure (defense in depth)
        """
        results = {
            'schemes_tested': [],
            'all_passed': True,
        }
        
        # Test 1: Kyber + ECDH hybrid KEM
        kyber_key = np.random.bytes(32)  # Simulated Kyber shared secret
        ecdh_key = np.random.bytes(32)   # Simulated ECDH shared secret
        
        # Combine using KDF
        combined_key = hashlib.sha256(kyber_key + ecdh_key).digest()
        
        kyber_ecdh_result = {
            'scheme': 'Kyber-768 + ECDH P-256',
            'kyber_key_size': len(kyber_key),
            'ecdh_key_size': len(ecdh_key),
            'combined_key_size': len(combined_key),
            'status': 'passed',
            'security_level': 'AES-256 equivalent',
        }
        results['schemes_tested'].append(kyber_ecdh_result)
        
        # Test 2: Dilithium + ECDSA hybrid signatures
        dilithium_sig = np.random.bytes(2420)  # Dilithium-3 signature size
        ecdsa_sig = np.random.bytes(64)        # ECDSA P-256 signature size
        
        # Both signatures must verify
        dilithium_valid = True  # Simulated verification
        ecdsa_valid = True      # Simulated verification
        
        dilithium_ecdsa_result = {
            'scheme': 'Dilithium-3 + ECDSA P-256',
            'dilithium_sig_size': len(dilithium_sig),
            'ecdsa_sig_size': len(ecdsa_sig),
            'dilithium_valid': dilithium_valid,
            'ecdsa_valid': ecdsa_valid,
            'status': 'passed' if (dilithium_valid and ecdsa_valid) else 'failed',
        }
        results['schemes_tested'].append(dilithium_ecdsa_result)
        
        # Test 3: Dual PRF key derivation
        prf1_output = hashlib.sha256(b'prf1_input').digest()
        prf2_output = hashlib.sha256(b'prf2_input').digest()
        dual_prf_key = bytes(a ^ b for a, b in zip(prf1_output, prf2_output))
        
        dual_prf_result = {
            'scheme': 'Dual PRF (SHA-256 XOR)',
            'output_size': len(dual_prf_key),
            'status': 'passed',
        }
        results['schemes_tested'].append(dual_prf_result)
        
        self.logger.info(f"Hybrid scheme testing complete",
                       schemes=len(results['schemes_tested']),
                       all_passed=results['all_passed'])
        
        return results
    
    def auto_switch_to_hybrid(self, vulnerability_detected: bool = False) -> Dict[str, Any]:
        """
        Automatically switch to hybrid PQ+classical mode if vulnerability detected
        
        Args:
            vulnerability_detected: Whether PQ vulnerability was found
        
        Returns:
            Switch status and new configuration
        
        Triggers:
        - Successful lattice attack
        - Timing side-channel leakage
        - Signature forgery
        - Algorithm deprecation (e.g., NIST downgrade)
        """
        current_mode = 'pq_only'
        
        if vulnerability_detected:
            new_mode = 'hybrid'
            
            self.logger.warning(f"Vulnerability detected, switching to hybrid mode",
                              previous=current_mode,
                              new=new_mode)
            
            return {
                'switch_triggered': True,
                'previous_mode': current_mode,
                'new_mode': new_mode,
                'hybrid_config': {
                    'kem': 'Kyber-768 + ECDH P-256',
                    'signature': 'Dilithium-3 + ECDSA P-256',
                    'kdf': 'Dual PRF (SHA-256)',
                },
                'security_level': 'AES-256 equivalent',
                'timestamp': datetime.now().isoformat(),
            }
        else:
            self.logger.info(f"No vulnerability detected, maintaining PQ-only mode")
            
            return {
                'switch_triggered': False,
                'current_mode': current_mode,
                'timestamp': datetime.now().isoformat(),
            }
    
    def measure_lattice_resistance(self, lattice_dimension: int = 256) -> Dict[str, Any]:
        """
        Measure resistance to lattice reduction attacks
        
        Args:
            lattice_dimension: Kyber lattice dimension (256, 512, 768)
        
        Returns:
            Resistance metrics
        
        Methods:
        - LLL reduction (polynomial time)
        - BKZ-20 reduction (exponential, more powerful)
        - Hermite factor δ (lower = harder to attack)
        
        Target Hermite factor: δ < 1.005 (secure against known attacks)
        """
        # Generate test lattice
        q = 3329
        lattice = self._generate_kyber_lattice(lattice_dimension, q)
        
        # Apply LLL reduction
        lll_start = time.time()
        reduced_lll = self._lll_reduce(lattice)
        lll_duration = time.time() - lll_start
        
        # Calculate Hermite factor
        det = np.linalg.det(lattice)
        shortest_vector_norm = np.min([np.linalg.norm(reduced_lll[i]) for i in range(len(reduced_lll))])
        hermite_factor = shortest_vector_norm / (det ** (1.0 / lattice_dimension))
        
        # Security assessment
        secure = hermite_factor < 1.005
        
        results = {
            'lattice_dimension': lattice_dimension,
            'lll_duration_sec': lll_duration,
            'hermite_factor': float(hermite_factor),
            'secure': secure,
            'security_margin': f"{(1.005 - hermite_factor) / 1.005 * 100:.1f}%",
            'estimated_attack_cost': self._estimate_attack_cost(lattice_dimension, hermite_factor),
        }
        
        self.logger.info(f"Lattice resistance measured",
                       dimension=lattice_dimension,
                       hermite=f"{hermite_factor:.6f}",
                       secure=secure)
        
        return results
    
    def _estimate_attack_cost(self, dimension: int, hermite_factor: float) -> str:
        """
        Estimate computational cost of successful lattice attack
        
        Returns:
            Attack cost estimate (e.g., "2^128 operations")
        """
        # Simplified estimate based on dimension and Hermite factor
        # Real attacks use BKZ with block size β
        
        if hermite_factor > 1.01:
            return "2^64 operations (insecure)"
        elif hermite_factor > 1.005:
            return "2^80 operations (marginal)"
        elif dimension >= 512:
            return "2^256 operations (secure)"
        else:
            return "2^128 operations (secure)"


