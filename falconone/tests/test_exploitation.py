"""
Unit tests for exploitation engine
Tests DOS attacks, downgrade attacks, MITM, and security features
"""

import pytest
import threading
import time
from unittest.mock import Mock, MagicMock, patch

from falconone.exploit.exploit_engine import (
    ExploitEngine, DOSAttack, DowngradeAttack, MITMAttack
)
from falconone.core.config import Config


@pytest.fixture
def mock_config():
    """Create mock configuration"""
    config = Mock(spec=Config)
    config.get = MagicMock(side_effect=lambda key, default=None: {
        'exploit.dos_enabled': True,
        'exploit.downgrade_enabled': True,
        'exploit.mitm_enabled': True,
        'exploit.rate_limit_per_hour': 100,
        'exploit.require_authorization': True
    }.get(key, default))
    return config


@pytest.fixture
def mock_logger():
    """Create mock logger"""
    return Mock()


@pytest.fixture
def exploit_engine(mock_config, mock_logger):
    """Create exploit engine instance"""
    return ExploitEngine(mock_config, mock_logger)


class TestExploitEngineInitialization:
    """Test exploit engine initialization"""
    
    def test_engine_creation(self, exploit_engine):
        """Test engine is created with correct settings"""
        assert exploit_engine is not None
        assert hasattr(exploit_engine, 'dos_attack')
        assert hasattr(exploit_engine, 'downgrade_attack')
        assert hasattr(exploit_engine, 'mitm_attack')
    
    def test_security_features_enabled(self, exploit_engine):
        """Test security features are enabled"""
        assert exploit_engine.rate_limit_enabled
        assert exploit_engine.authorization_required


class TestDOSAttack:
    """Test Denial-of-Service attack functionality"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_dos_attach_request(self, mock_sdr, exploit_engine):
        """Test DOS attach request flood"""
        # Setup mock SDR
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        # Execute DOS attack
        result = exploit_engine.dos_attack.attach_request_flood(
            target_frequency=900.0,
            duration=1,  # 1 second test
            rate=100  # 100 requests/sec
        )
        
        assert result['status'] == 'completed'
        assert result['attack_type'] == 'attach_request_flood'
        assert result['packets_sent'] > 0
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_dos_detach_flood(self, mock_sdr, exploit_engine):
        """Test DOS detach request flood"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.dos_attack.detach_flood(
            target_frequency=1800.0,
            duration=1,
            rate=150
        )
        
        assert result['status'] == 'completed'
        assert result['attack_type'] == 'detach_flood'
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_dos_paging_flood(self, mock_sdr, exploit_engine):
        """Test DOS paging message flood"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.dos_attack.paging_flood(
            target_frequency=2100.0,
            duration=1,
            rate=200
        )
        
        assert result['status'] == 'completed'
        assert result['attack_type'] == 'paging_flood'
    
    def test_dos_rate_limiting(self, exploit_engine):
        """Test DOS attack rate limiting"""
        # Exceed rate limit
        for i in range(150):  # Exceed 100/hour limit
            try:
                exploit_engine.dos_attack.attach_request_flood(
                    target_frequency=900.0,
                    duration=0.1,
                    rate=10
                )
            except Exception as e:
                if "rate limit" in str(e).lower():
                    assert True
                    return
        
        pytest.fail("Rate limiting not enforced")


class TestDowngradeAttack:
    """Test protocol downgrade attack functionality"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_lte_to_3g_downgrade(self, mock_sdr, exploit_engine):
        """Test LTE to 3G downgrade attack"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.downgrade_attack.force_lte_to_3g(
            target_frequency=1850.0,
            target_imsi="001010123456789"
        )
        
        assert result['status'] in ['completed', 'initiated']
        assert result['attack_type'] == 'lte_to_3g_downgrade'
        assert result['target_protocol'] == '3G'
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_3g_to_2g_downgrade(self, mock_sdr, exploit_engine):
        """Test 3G to 2G downgrade attack"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.downgrade_attack.force_3g_to_2g(
            target_frequency=2100.0,
            target_imsi="001010987654321"
        )
        
        assert result['status'] in ['completed', 'initiated']
        assert result['attack_type'] == '3g_to_2g_downgrade'
        assert result['target_protocol'] == '2G'
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_encryption_downgrade(self, mock_sdr, exploit_engine):
        """Test encryption algorithm downgrade"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.downgrade_attack.downgrade_encryption(
            target_frequency=900.0,
            from_algorithm='A5/3',
            to_algorithm='A5/1'
        )
        
        assert result['status'] in ['completed', 'initiated']
        assert result['from_algorithm'] == 'A5/3'
        assert result['to_algorithm'] == 'A5/1'
    
    def test_downgrade_authorization(self, exploit_engine):
        """Test downgrade attack authorization requirement"""
        # Should require authorization token
        with pytest.raises(Exception) as exc_info:
            exploit_engine.downgrade_attack.force_lte_to_3g(
                target_frequency=1850.0,
                target_imsi="001010123456789",
                authorization_token=None
            )
        
        assert "authorization" in str(exc_info.value).lower()


class TestMITMAttack:
    """Test Man-in-the-Middle attack functionality"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_fake_base_station_setup(self, mock_sdr, exploit_engine):
        """Test fake base station setup"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.mitm_attack.setup_fake_base_station(
            frequency=900.0,
            cell_id=123,
            mcc=1,
            mnc=1,
            lac=4000
        )
        
        assert result['status'] == 'active'
        assert result['cell_id'] == 123
        assert result['frequency'] == 900.0
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_imsi_catching(self, mock_sdr, exploit_engine):
        """Test IMSI catching functionality"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        # Setup fake base station first
        exploit_engine.mitm_attack.setup_fake_base_station(
            frequency=900.0,
            cell_id=456,
            mcc=1,
            mnc=1,
            lac=5000
        )
        
        # Start IMSI catching
        result = exploit_engine.mitm_attack.catch_imsi(
            duration=5  # 5 seconds
        )
        
        assert result['status'] == 'completed'
        assert 'imsis_captured' in result
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_sms_interception(self, mock_sdr, exploit_engine):
        """Test SMS interception"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        # Setup fake base station
        exploit_engine.mitm_attack.setup_fake_base_station(
            frequency=1800.0,
            cell_id=789,
            mcc=1,
            mnc=1,
            lac=6000
        )
        
        # Start SMS interception
        result = exploit_engine.mitm_attack.intercept_sms(
            target_imsi="001010123456789",
            duration=10
        )
        
        assert result['status'] in ['active', 'completed']
        assert 'messages_intercepted' in result
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_call_interception(self, mock_sdr, exploit_engine):
        """Test voice call interception"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.mitm_attack.intercept_call(
            target_imsi="001010123456789",
            frequency=900.0
        )
        
        assert result['status'] in ['active', 'recording']
        assert 'call_id' in result


class TestExploitLogging:
    """Test exploit activity logging"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_attack_logging(self, mock_sdr, exploit_engine, mock_logger):
        """Test that attacks are logged to audit log"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        # Execute attack
        exploit_engine.dos_attack.attach_request_flood(
            target_frequency=900.0,
            duration=0.5,
            rate=50
        )
        
        # Verify logging called
        assert mock_logger.info.called or mock_logger.warning.called
    
    def test_sensitive_parameter_redaction(self, exploit_engine, mock_logger):
        """Test that sensitive parameters are redacted in logs"""
        # This should redact IMSI in logs
        try:
            exploit_engine.downgrade_attack.force_lte_to_3g(
                target_frequency=1850.0,
                target_imsi="001010123456789"
            )
        except:
            pass
        
        # Check that IMSI was redacted in log calls
        if mock_logger.info.called:
            call_args = str(mock_logger.info.call_args)
            # IMSI should be partially redacted (e.g., "001010*****789")
            assert "001010123456789" not in call_args or "*" in call_args


class TestExploitSafety:
    """Test safety mechanisms"""
    
    def test_geographic_restriction(self, exploit_engine):
        """Test that attacks respect geographic restrictions"""
        # Should block attacks in restricted regions
        with pytest.raises(Exception) as exc_info:
            exploit_engine.dos_attack.attach_request_flood(
                target_frequency=900.0,
                duration=1,
                rate=100,
                location={'country': 'US'}  # Example restricted country
            )
        
        # Should indicate geographic restriction
        # (This test depends on implementation)
    
    def test_emergency_stop(self, exploit_engine):
        """Test emergency stop functionality"""
        # Start long-running attack
        thread = threading.Thread(
            target=exploit_engine.dos_attack.attach_request_flood,
            kwargs={
                'target_frequency': 900.0,
                'duration': 60,  # 60 seconds
                'rate': 100
            }
        )
        thread.start()
        
        # Wait a bit
        time.sleep(0.5)
        
        # Trigger emergency stop
        exploit_engine.emergency_stop()
        
        # Wait for thread to finish
        thread.join(timeout=2)
        
        # Thread should have stopped
        assert not thread.is_alive()


class TestExploitMetrics:
    """Test attack metrics collection"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_attack_metrics(self, mock_sdr, exploit_engine):
        """Test that attack metrics are collected"""
        mock_device = Mock()
        mock_sdr.return_value = mock_device
        
        result = exploit_engine.dos_attack.attach_request_flood(
            target_frequency=900.0,
            duration=1,
            rate=100
        )
        
        # Should include performance metrics
        assert 'duration_ms' in result
        assert 'packets_sent' in result
        assert 'success_rate' in result or 'throughput' in result


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
