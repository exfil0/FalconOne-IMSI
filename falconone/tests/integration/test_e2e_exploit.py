"""
End-to-end integration tests for exploit workflow
Tests complete exploit process from initialization to results
"""

import pytest
import time
from unittest.mock import Mock, patch
import sys
import os

# Add parent directory to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

from falconone.core.orchestrator import SystemOrchestrator
from falconone.exploit.exploit_engine import ExploitEngine
from falconone.utils.database import DatabaseManager


@pytest.fixture
def temp_database(tmp_path):
    """Create temporary test database"""
    db_path = tmp_path / "test_e2e.db"
    db = DatabaseManager(str(db_path))
    yield db
    db.close()


@pytest.fixture
@patch('falconone.sdr.sdr_layer.SoapySDR')
def orchestrator(mock_soapy, temp_database, tmp_path):
    """Create system orchestrator for integration testing"""
    # Mock configuration
    config = {
        'database_path': str(tmp_path / "test_e2e.db"),
        'sdr': {
            'devices': ['USRP'],
            'priority': 'USRP'
        },
        'exploit': {
            'dos_enabled': True,
            'downgrade_enabled': True,
            'mitm_enabled': True
        }
    }
    
    # Mock SoapySDR device
    mock_soapy.Device.enumerate.return_value = [
        {'driver': 'usrp', 'serial': 'TEST123'}
    ]
    
    orchestrator = SystemOrchestrator(config)
    yield orchestrator
    orchestrator.shutdown()


class TestDOSExploitWorkflow:
    """Test complete DOS attack workflow"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_dos_attack_end_to_end(self, mock_sdr, orchestrator):
        """Test complete DOS attack from start to finish"""
        # 1. Initialize exploit engine
        assert orchestrator.exploit_engine is not None
        
        # 2. Configure DOS attack parameters
        attack_params = {
            'attack_type': 'attach_request_flood',
            'target_frequency': 900.0,
            'duration': 1,  # 1 second
            'rate': 100
        }
        
        # 3. Execute attack
        result = orchestrator.execute_exploit('dos', attack_params)
        
        # 4. Verify attack executed
        assert result is not None
        assert result.get('status') == 'completed'
        assert 'packets_sent' in result
        
        # 5. Verify results logged to database
        logs = orchestrator.database.get_exploit_logs()
        assert len(logs) > 0
        assert logs[-1]['attack_type'] == 'dos'
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_dos_attack_with_monitoring(self, mock_sdr, orchestrator):
        """Test DOS attack with real-time monitoring"""
        # Enable monitoring
        orchestrator.start_monitoring('GSM', 900.0)
        
        # Execute attack
        attack_params = {
            'attack_type': 'detach_flood',
            'target_frequency': 900.0,
            'duration': 2,
            'rate': 150
        }
        
        result = orchestrator.execute_exploit('dos', attack_params)
        
        # Verify monitoring captured attack traffic
        captures = orchestrator.database.get_signal_captures()
        assert len(captures) > 0
        
        # Stop monitoring
        orchestrator.stop_monitoring()
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_dos_attack_error_handling(self, mock_sdr, orchestrator):
        """Test DOS attack with simulated errors"""
        # Configure mock to fail
        mock_sdr.side_effect = Exception("SDR device error")
        
        # Attack should handle error gracefully
        attack_params = {
            'attack_type': 'paging_flood',
            'target_frequency': 900.0,
            'duration': 1,
            'rate': 100
        }
        
        result = orchestrator.execute_exploit('dos', attack_params)
        
        # Should return error status
        assert result is not None
        assert result.get('status') in ['failed', 'error']


class TestDowngradeExploitWorkflow:
    """Test complete downgrade attack workflow"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_lte_downgrade_workflow(self, mock_sdr, orchestrator):
        """Test LTE to 3G downgrade attack workflow"""
        # 1. Scan for LTE cells
        orchestrator.start_monitoring('LTE', 1850.0)
        time.sleep(0.5)
        
        # 2. Identify target UE
        target_imsi = "001010123456789"
        
        # 3. Execute downgrade attack
        attack_params = {
            'attack_type': 'lte_to_3g',
            'target_frequency': 1850.0,
            'target_imsi': target_imsi,
            'authorization_token': 'test-token'
        }
        
        result = orchestrator.execute_exploit('downgrade', attack_params)
        
        # 4. Verify downgrade succeeded
        assert result is not None
        assert result.get('status') in ['completed', 'initiated']
        assert result.get('target_protocol') == '3G'
        
        # 5. Verify logged
        logs = orchestrator.database.get_exploit_logs()
        downgrade_logs = [l for l in logs if l['attack_type'] == 'downgrade']
        assert len(downgrade_logs) > 0
        
        orchestrator.stop_monitoring()
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_encryption_downgrade_workflow(self, mock_sdr, orchestrator):
        """Test encryption algorithm downgrade workflow"""
        # Execute encryption downgrade
        attack_params = {
            'attack_type': 'encryption_downgrade',
            'target_frequency': 900.0,
            'from_algorithm': 'A5/3',
            'to_algorithm': 'A5/1',
            'authorization_token': 'test-token'
        }
        
        result = orchestrator.execute_exploit('downgrade', attack_params)
        
        assert result is not None
        assert result.get('from_algorithm') == 'A5/3'
        assert result.get('to_algorithm') == 'A5/1'


class TestMITMExploitWorkflow:
    """Test complete MITM attack workflow"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_imsi_catching_workflow(self, mock_sdr, orchestrator):
        """Test complete IMSI catching workflow"""
        # 1. Setup fake base station
        fbs_params = {
            'frequency': 900.0,
            'cell_id': 123,
            'mcc': 1,
            'mnc': 1,
            'lac': 4000
        }
        
        fbs_result = orchestrator.exploit_engine.mitm_attack.setup_fake_base_station(**fbs_params)
        assert fbs_result['status'] == 'active'
        
        # 2. Start IMSI catching
        catch_result = orchestrator.exploit_engine.mitm_attack.catch_imsi(duration=2)
        
        # 3. Verify IMSIs captured
        assert catch_result['status'] == 'completed'
        assert 'imsis_captured' in catch_result
        
        # 4. Verify stored in database
        detections = orchestrator.database.get_detection_events()
        imsi_events = [d for d in detections if 'imsi' in d.get('event_type', '').lower()]
        # May or may not have events depending on simulation
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_sms_interception_workflow(self, mock_sdr, orchestrator):
        """Test complete SMS interception workflow"""
        # 1. Setup fake base station
        fbs_result = orchestrator.exploit_engine.mitm_attack.setup_fake_base_station(
            frequency=1800.0,
            cell_id=456,
            mcc=1,
            mnc=1,
            lac=5000
        )
        
        # 2. Start SMS interception
        intercept_result = orchestrator.exploit_engine.mitm_attack.intercept_sms(
            target_imsi="001010123456789",
            duration=3
        )
        
        # 3. Verify interception active
        assert intercept_result['status'] in ['active', 'completed']
        assert 'messages_intercepted' in intercept_result


class TestMonitoringIntegration:
    """Test monitoring integration with exploits"""
    
    @patch('falconone.sdr.sdr_layer.SDRDevice')
    def test_gsm_monitoring_with_exploit(self, mock_sdr, orchestrator):
        """Test GSM monitoring captures exploit traffic"""
        # Start GSM monitoring
        orchestrator.start_monitoring('GSM', 900.0)
        time.sleep(0.5)
        
        # Execute DOS attack
        attack_params = {
            'attack_type': 'attach_request_flood',
            'target_frequency': 900.0,
            'duration': 1,
            'rate': 50
        }
        
        orchestrator.execute_exploit('dos', attack_params)
        
        # Verify captures recorded
        captures = orchestrator.database.get_signal_captures()
        assert len(captures) > 0
        
        # Verify GSM-specific data
        gsm_captures = [c for c in captures if c.get('technology') == 'GSM']
        assert len(gsm_captures) > 0
        
        orchestrator.stop_monitoring()
    
    @patch('falconone.sdr.sdr_layer.SDRDevice')
    def test_lte_monitoring_with_exploit(self, mock_sdr, orchestrator):
        """Test LTE monitoring captures exploit traffic"""
        # Start LTE monitoring
        orchestrator.start_monitoring('LTE', 1850.0)
        time.sleep(0.5)
        
        # Execute downgrade attack
        attack_params = {
            'attack_type': 'lte_to_3g',
            'target_frequency': 1850.0,
            'target_imsi': "001010123456789",
            'authorization_token': 'test-token'
        }
        
        orchestrator.execute_exploit('downgrade', attack_params)
        
        # Verify LTE captures
        captures = orchestrator.database.get_signal_captures()
        lte_captures = [c for c in captures if c.get('technology') == 'LTE']
        assert len(lte_captures) > 0
        
        orchestrator.stop_monitoring()


class TestDatabasePersistence:
    """Test database persistence across operations"""
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_session_persistence(self, mock_sdr, orchestrator):
        """Test that session data persists correctly"""
        # Create session
        session_id = orchestrator.create_session(
            technology='LTE',
            frequency=1850.0,
            bandwidth=20.0
        )
        
        # Execute attack
        attack_params = {
            'attack_type': 'dos',
            'target_frequency': 1850.0,
            'duration': 1,
            'rate': 100
        }
        
        orchestrator.execute_exploit('dos', attack_params)
        
        # End session
        orchestrator.end_session(session_id)
        
        # Verify session in database
        session = orchestrator.database.get_session_by_id(session_id)
        assert session is not None
        assert session.get('status') == 'completed'
    
    @patch('falconone.exploit.exploit_engine.SDRDevice')
    def test_exploit_log_persistence(self, mock_sdr, orchestrator):
        """Test exploit logs persist correctly"""
        # Execute multiple attacks
        for i in range(3):
            attack_params = {
                'attack_type': 'attach_request_flood',
                'target_frequency': 900.0 + (i * 100),
                'duration': 0.5,
                'rate': 50
            }
            orchestrator.execute_exploit('dos', attack_params)
        
        # Verify all logged
        logs = orchestrator.database.get_exploit_logs()
        assert len(logs) >= 3


class TestErrorRecovery:
    """Test error recovery mechanisms"""
    
    @patch('falconone.sdr.sdr_layer.SDRDevice')
    def test_sdr_failure_recovery(self, mock_sdr, orchestrator):
        """Test recovery from SDR device failure"""
        # Simulate SDR failure mid-attack
        mock_sdr.side_effect = [None, None, Exception("Device disconnected")]
        
        attack_params = {
            'attack_type': 'dos',
            'target_frequency': 900.0,
            'duration': 1,
            'rate': 100
        }
        
        # Should handle gracefully
        result = orchestrator.execute_exploit('dos', attack_params)
        
        # Error should be logged
        assert result is not None
        
        # System should still be operational
        assert orchestrator.is_operational()
    
    def test_database_connection_recovery(self, orchestrator):
        """Test recovery from database connection issues"""
        # Close database
        orchestrator.database.close()
        
        # Try to execute operation (should reconnect or handle gracefully)
        try:
            session_id = orchestrator.create_session(
                technology='GSM',
                frequency=900.0,
                bandwidth=0.2
            )
            # If it succeeds, connection was recovered
            assert session_id is not None
        except Exception:
            # If it fails, error should be logged
            pass


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])
